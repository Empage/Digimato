
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000cc8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000004  00800060  00000cc8  00000d5c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000034  00800064  00800064  00000d60  2**0
                  ALLOC
  3 .debug_aranges 00000020  00000000  00000000  00000d60  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000067  00000000  00000000  00000d80  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000006a0  00000000  00000000  00000de7  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000209  00000000  00000000  00001487  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000008fd  00000000  00000000  00001690  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000080  00000000  00000000  00001f90  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000441  00000000  00000000  00002010  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000313  00000000  00000000  00002451  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000048  00000000  00000000  00002764  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 77 00 	jmp	0xee	; 0xee <__ctors_end>
   4:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
   8:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
   c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  10:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  14:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  18:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  1c:	0c 94 35 06 	jmp	0xc6a	; 0xc6a <__vector_7>
  20:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  24:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  28:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  2c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  30:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  34:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  38:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  3c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  40:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  44:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  48:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  4c:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>
  50:	0c 94 94 00 	jmp	0x128	; 0x128 <__bad_interrupt>

00000054 <sircs_param>:
  54:	01 0f 15 07 0b 07 0b 07 0b 0f 14 00 0f 14 00 01     ................
  64:	00                                                  .

00000065 <nec_param>:
  65:	02 04 0d 0e 24 04 0d 04 0d 00 10 10 20 20 01 01     ....$.......  ..
  75:	00                                                  .

00000076 <nec_rep_param>:
  76:	02 04 0d 0e 24 04 0d 04 0d 00 00 00 00 00 01 01     ....$...........
  86:	00                                                  .

00000087 <samsung_param>:
  87:	03 05 0c 0e 1d 05 0c 04 0a 00 10 15 25 25 01 01     ............%%..
  97:	00                                                  .

00000098 <matsushita_param>:
  98:	04 07 13 17 38 07 13 07 13 0c 18 00 0c 18 01 01     ....8...........
  a8:	00                                                  .

000000a9 <kaseikyo_param>:
  a9:	05 02 0b 0c 1a 02 0b 02 0b 00 10 1c 28 30 01 01     ............(0..
  b9:	00                                                  .

000000ba <rc5_param>:
  ba:	07 0b 10 0b 10 00 00 00 00 01 07 07 0d 0d 00 00     ................
  ca:	01                                                  .

000000cb <denon_param>:
  cb:	08 03 06 17 1e 03 06 0a 0d 00 05 05 0f 0f 01 00     ................
  db:	00                                                  .

000000dc <ruwido_param>:
  dc:	17 03 06 03 06 00 00 00 00 00 09 09 11 16 00 00     ................
  ec:	03 00                                               ..

000000ee <__ctors_end>:
  ee:	11 24       	eor	r1, r1
  f0:	1f be       	out	0x3f, r1	; 63
  f2:	cf e5       	ldi	r28, 0x5F	; 95
  f4:	d8 e0       	ldi	r29, 0x08	; 8
  f6:	de bf       	out	0x3e, r29	; 62
  f8:	cd bf       	out	0x3d, r28	; 61

000000fa <__do_copy_data>:
  fa:	10 e0       	ldi	r17, 0x00	; 0
  fc:	a0 e6       	ldi	r26, 0x60	; 96
  fe:	b0 e0       	ldi	r27, 0x00	; 0
 100:	e8 ec       	ldi	r30, 0xC8	; 200
 102:	fc e0       	ldi	r31, 0x0C	; 12
 104:	02 c0       	rjmp	.+4      	; 0x10a <.do_copy_data_start>

00000106 <.do_copy_data_loop>:
 106:	05 90       	lpm	r0, Z+
 108:	0d 92       	st	X+, r0

0000010a <.do_copy_data_start>:
 10a:	a4 36       	cpi	r26, 0x64	; 100
 10c:	b1 07       	cpc	r27, r17
 10e:	d9 f7       	brne	.-10     	; 0x106 <.do_copy_data_loop>

00000110 <__do_clear_bss>:
 110:	10 e0       	ldi	r17, 0x00	; 0
 112:	a4 e6       	ldi	r26, 0x64	; 100
 114:	b0 e0       	ldi	r27, 0x00	; 0
 116:	01 c0       	rjmp	.+2      	; 0x11a <.do_clear_bss_start>

00000118 <.do_clear_bss_loop>:
 118:	1d 92       	st	X+, r1

0000011a <.do_clear_bss_start>:
 11a:	a8 39       	cpi	r26, 0x98	; 152
 11c:	b1 07       	cpc	r27, r17
 11e:	e1 f7       	brne	.-8      	; 0x118 <.do_clear_bss_loop>
 120:	0e 94 11 02 	call	0x422	; 0x422 <main>
 124:	0c 94 62 06 	jmp	0xcc4	; 0xcc4 <_exit>

00000128 <__bad_interrupt>:
 128:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012c <irmp_init>:
#ifndef ANALYZE
void
irmp_init (void)
{
#ifndef PIC_CCS_COMPILER
    IRMP_PORT &= ~(1<<IRMP_BIT);                                        // deactivate pullup
 12c:	c6 98       	cbi	0x18, 6	; 24
    IRMP_DDR &= ~(1<<IRMP_BIT);                                         // set pin to input
 12e:	be 98       	cbi	0x17, 6	; 23
#endif // PIC_CCS_COMPILER

#if IRMP_LOGGING == 1
    irmp_uart_init ();
#endif
}
 130:	08 95       	ret

00000132 <irmp_get_data>:
 *  @return    TRUE: successful, FALSE: failed
 *---------------------------------------------------------------------------------------------------------------------------------------------------
 */
uint8_t
irmp_get_data (IRMP_DATA * irmp_data_p)
{
 132:	fc 01       	movw	r30, r24
    uint8_t   rtc = FALSE;

    if (irmp_ir_detected)
 134:	80 91 83 00 	lds	r24, 0x0083
 138:	88 23       	and	r24, r24
 13a:	09 f4       	brne	.+2      	; 0x13e <irmp_get_data+0xc>
 13c:	a8 c0       	rjmp	.+336    	; 0x28e <irmp_get_data+0x15c>
    {
        switch (irmp_protocol)
 13e:	80 91 84 00 	lds	r24, 0x0084
 142:	87 30       	cpi	r24, 0x07	; 7
 144:	09 f4       	brne	.+2      	; 0x148 <irmp_get_data+0x16>
 146:	79 c0       	rjmp	.+242    	; 0x23a <irmp_get_data+0x108>
 148:	88 30       	cpi	r24, 0x08	; 8
 14a:	30 f4       	brcc	.+12     	; 0x158 <irmp_get_data+0x26>
 14c:	82 30       	cpi	r24, 0x02	; 2
 14e:	91 f1       	breq	.+100    	; 0x1b4 <irmp_get_data+0x82>
 150:	83 30       	cpi	r24, 0x03	; 3
 152:	09 f0       	breq	.+2      	; 0x156 <irmp_get_data+0x24>
 154:	7b c0       	rjmp	.+246    	; 0x24c <irmp_get_data+0x11a>
 156:	07 c0       	rjmp	.+14     	; 0x166 <irmp_get_data+0x34>
 158:	81 31       	cpi	r24, 0x11	; 17
 15a:	09 f4       	brne	.+2      	; 0x15e <irmp_get_data+0x2c>
 15c:	5a c0       	rjmp	.+180    	; 0x212 <irmp_get_data+0xe0>
 15e:	87 31       	cpi	r24, 0x17	; 23
 160:	09 f0       	breq	.+2      	; 0x164 <irmp_get_data+0x32>
 162:	74 c0       	rjmp	.+232    	; 0x24c <irmp_get_data+0x11a>
 164:	56 c0       	rjmp	.+172    	; 0x212 <irmp_get_data+0xe0>
        {
#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
            case IRMP_SAMSUNG_PROTOCOL:
                if ((irmp_command >> 8) == (~irmp_command & 0x00FF))
 166:	20 91 87 00 	lds	r18, 0x0087
 16a:	30 91 88 00 	lds	r19, 0x0088
 16e:	80 91 87 00 	lds	r24, 0x0087
 172:	90 91 88 00 	lds	r25, 0x0088
 176:	23 2f       	mov	r18, r19
 178:	33 27       	eor	r19, r19
 17a:	80 95       	com	r24
 17c:	90 95       	com	r25
 17e:	90 70       	andi	r25, 0x00	; 0
 180:	28 17       	cp	r18, r24
 182:	39 07       	cpc	r19, r25
 184:	09 f0       	breq	.+2      	; 0x188 <irmp_get_data+0x56>
 186:	80 c0       	rjmp	.+256    	; 0x288 <irmp_get_data+0x156>
                {
                    irmp_command &= 0xff;
 188:	80 91 87 00 	lds	r24, 0x0087
 18c:	90 91 88 00 	lds	r25, 0x0088
 190:	90 70       	andi	r25, 0x00	; 0
 192:	90 93 88 00 	sts	0x0088, r25
 196:	80 93 87 00 	sts	0x0087, r24
                    irmp_command |= irmp_id << 8;
 19a:	20 91 87 00 	lds	r18, 0x0087
 19e:	30 91 88 00 	lds	r19, 0x0088
 1a2:	80 91 89 00 	lds	r24, 0x0089
 1a6:	90 91 8a 00 	lds	r25, 0x008A
 1aa:	98 2f       	mov	r25, r24
 1ac:	88 27       	eor	r24, r24
 1ae:	82 2b       	or	r24, r18
 1b0:	93 2b       	or	r25, r19
 1b2:	2a c0       	rjmp	.+84     	; 0x208 <irmp_get_data+0xd6>
                }
                break;
#endif
#if IRMP_SUPPORT_NEC_PROTOCOL == 1
            case IRMP_NEC_PROTOCOL:
                if ((irmp_command >> 8) == (~irmp_command & 0x00FF))
 1b4:	20 91 87 00 	lds	r18, 0x0087
 1b8:	30 91 88 00 	lds	r19, 0x0088
 1bc:	80 91 87 00 	lds	r24, 0x0087
 1c0:	90 91 88 00 	lds	r25, 0x0088
 1c4:	23 2f       	mov	r18, r19
 1c6:	33 27       	eor	r19, r19
 1c8:	80 95       	com	r24
 1ca:	90 95       	com	r25
 1cc:	90 70       	andi	r25, 0x00	; 0
 1ce:	28 17       	cp	r18, r24
 1d0:	39 07       	cpc	r19, r25
 1d2:	a9 f0       	breq	.+42     	; 0x1fe <irmp_get_data+0xcc>
                {
                    irmp_command &= 0xff;
                    rtc = TRUE;
                }
                else if (irmp_address == 0x87EE)
 1d4:	80 91 85 00 	lds	r24, 0x0085
 1d8:	90 91 86 00 	lds	r25, 0x0086
 1dc:	8e 5e       	subi	r24, 0xEE	; 238
 1de:	97 48       	sbci	r25, 0x87	; 135
 1e0:	09 f0       	breq	.+2      	; 0x1e4 <irmp_get_data+0xb2>
 1e2:	52 c0       	rjmp	.+164    	; 0x288 <irmp_get_data+0x156>
                {
                    ANALYZE_PRINTF ("Switching to APPLE protocol\n");
                    irmp_protocol = IRMP_APPLE_PROTOCOL;
 1e4:	8b e0       	ldi	r24, 0x0B	; 11
 1e6:	80 93 84 00 	sts	0x0084, r24
                    irmp_address = (irmp_command & 0xFF00) >> 8;
 1ea:	80 91 87 00 	lds	r24, 0x0087
 1ee:	90 91 88 00 	lds	r25, 0x0088
 1f2:	89 2f       	mov	r24, r25
 1f4:	99 27       	eor	r25, r25
 1f6:	90 93 86 00 	sts	0x0086, r25
 1fa:	80 93 85 00 	sts	0x0085, r24
                    irmp_command &= 0x00FF;
 1fe:	80 91 87 00 	lds	r24, 0x0087
 202:	90 91 88 00 	lds	r25, 0x0088
 206:	90 70       	andi	r25, 0x00	; 0
 208:	90 93 88 00 	sts	0x0088, r25
 20c:	80 93 87 00 	sts	0x0087, r24
 210:	1d c0       	rjmp	.+58     	; 0x24c <irmp_get_data+0x11a>
                break;
#endif
#if IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
            case IRMP_SIEMENS_PROTOCOL:
            case IRMP_RUWIDO_PROTOCOL:
                if (((irmp_command >> 1) & 0x0001) == (~irmp_command & 0x0001))
 212:	80 91 87 00 	lds	r24, 0x0087
 216:	90 91 88 00 	lds	r25, 0x0088
 21a:	20 91 87 00 	lds	r18, 0x0087
 21e:	30 91 88 00 	lds	r19, 0x0088
 222:	96 95       	lsr	r25
 224:	87 95       	ror	r24
 226:	82 27       	eor	r24, r18
 228:	80 ff       	sbrs	r24, 0
 22a:	2e c0       	rjmp	.+92     	; 0x288 <irmp_get_data+0x156>
                {
                    irmp_command >>= 1;
 22c:	80 91 87 00 	lds	r24, 0x0087
 230:	90 91 88 00 	lds	r25, 0x0088
 234:	96 95       	lsr	r25
 236:	87 95       	ror	r24
 238:	e7 cf       	rjmp	.-50     	; 0x208 <irmp_get_data+0xd6>
                }
                break;
#endif
#if IRMP_SUPPORT_RC5_PROTOCOL == 1
            case IRMP_RC5_PROTOCOL:
                irmp_address &= ~0x20;                              // clear toggle bit
 23a:	80 91 85 00 	lds	r24, 0x0085
 23e:	90 91 86 00 	lds	r25, 0x0086
 242:	8f 7d       	andi	r24, 0xDF	; 223
 244:	90 93 86 00 	sts	0x0086, r25
 248:	80 93 85 00 	sts	0x0085, r24
                rtc = TRUE;
        }

        if (rtc)
        {
            irmp_data_p->protocol = irmp_protocol;
 24c:	80 91 84 00 	lds	r24, 0x0084
 250:	80 83       	st	Z, r24
            irmp_data_p->address = irmp_address;
 252:	80 91 85 00 	lds	r24, 0x0085
 256:	90 91 86 00 	lds	r25, 0x0086
 25a:	92 83       	std	Z+2, r25	; 0x02
 25c:	81 83       	std	Z+1, r24	; 0x01
            irmp_data_p->command = irmp_command;
 25e:	80 91 87 00 	lds	r24, 0x0087
 262:	90 91 88 00 	lds	r25, 0x0088
 266:	94 83       	std	Z+4, r25	; 0x04
 268:	83 83       	std	Z+3, r24	; 0x03
            irmp_data_p->flags   = irmp_flags;
 26a:	80 91 8b 00 	lds	r24, 0x008B
 26e:	85 83       	std	Z+5, r24	; 0x05
            irmp_command = 0;
 270:	10 92 88 00 	sts	0x0088, r1
 274:	10 92 87 00 	sts	0x0087, r1
            irmp_address = 0;
 278:	10 92 86 00 	sts	0x0086, r1
 27c:	10 92 85 00 	sts	0x0085, r1
            irmp_flags   = 0;
 280:	10 92 8b 00 	sts	0x008B, r1
 284:	81 e0       	ldi	r24, 0x01	; 1
 286:	01 c0       	rjmp	.+2      	; 0x28a <irmp_get_data+0x158>
 288:	80 e0       	ldi	r24, 0x00	; 0
        }

        irmp_ir_detected = FALSE;
 28a:	10 92 83 00 	sts	0x0083, r1
    }

    return rtc;
}
 28e:	08 95       	ret

00000290 <irmp_store_bit>:
// verhindert, dass irmp_store_bit() inline compiliert wird:
// static void irmp_store_bit (uint8_t) __attribute__ ((noinline));

static void
irmp_store_bit (uint8_t value)
{
 290:	f8 2f       	mov	r31, r24
        first_bit = value;
    }
    else
#endif

    if (irmp_bit >= irmp_param.address_offset && irmp_bit < irmp_param.address_end)
 292:	60 91 71 00 	lds	r22, 0x0071
 296:	70 91 7b 00 	lds	r23, 0x007B
 29a:	67 17       	cp	r22, r23
 29c:	38 f1       	brcs	.+78     	; 0x2ec <irmp_store_bit+0x5c>
 29e:	80 91 7c 00 	lds	r24, 0x007C
 2a2:	68 17       	cp	r22, r24
 2a4:	18 f5       	brcc	.+70     	; 0x2ec <irmp_store_bit+0x5c>
    {
        if (irmp_param.lsb_first)
 2a6:	80 91 81 00 	lds	r24, 0x0081
 2aa:	2f 2f       	mov	r18, r31
 2ac:	30 e0       	ldi	r19, 0x00	; 0
 2ae:	40 91 8c 00 	lds	r20, 0x008C
 2b2:	50 91 8d 00 	lds	r21, 0x008D
 2b6:	88 23       	and	r24, r24
 2b8:	81 f0       	breq	.+32     	; 0x2da <irmp_store_bit+0x4a>
        {
            irmp_tmp_address |= (((uint16_t) (value)) << (irmp_bit - irmp_param.address_offset));   // CV wants cast
 2ba:	86 2f       	mov	r24, r22
 2bc:	90 e0       	ldi	r25, 0x00	; 0
 2be:	87 1b       	sub	r24, r23
 2c0:	91 09       	sbc	r25, r1
 2c2:	02 c0       	rjmp	.+4      	; 0x2c8 <irmp_store_bit+0x38>
 2c4:	22 0f       	add	r18, r18
 2c6:	33 1f       	adc	r19, r19
 2c8:	8a 95       	dec	r24
 2ca:	e2 f7       	brpl	.-8      	; 0x2c4 <irmp_store_bit+0x34>
 2cc:	42 2b       	or	r20, r18
 2ce:	53 2b       	or	r21, r19
 2d0:	50 93 8d 00 	sts	0x008D, r21
 2d4:	40 93 8c 00 	sts	0x008C, r20
 2d8:	69 c0       	rjmp	.+210    	; 0x3ac <irmp_store_bit+0x11c>
        }
        else
        {
            irmp_tmp_address <<= 1;
            irmp_tmp_address |= value;
 2da:	44 0f       	add	r20, r20
 2dc:	55 1f       	adc	r21, r21
 2de:	24 2b       	or	r18, r20
 2e0:	35 2b       	or	r19, r21
 2e2:	30 93 8d 00 	sts	0x008D, r19
 2e6:	20 93 8c 00 	sts	0x008C, r18
 2ea:	60 c0       	rjmp	.+192    	; 0x3ac <irmp_store_bit+0x11c>
        }
    }
    else if (irmp_bit >= irmp_param.command_offset && irmp_bit < irmp_param.command_end)
 2ec:	70 91 7d 00 	lds	r23, 0x007D
 2f0:	67 17       	cp	r22, r23
 2f2:	18 f1       	brcs	.+70     	; 0x33a <irmp_store_bit+0xaa>
 2f4:	80 91 7e 00 	lds	r24, 0x007E
 2f8:	68 17       	cp	r22, r24
 2fa:	f8 f4       	brcc	.+62     	; 0x33a <irmp_store_bit+0xaa>
    {
        if (irmp_param.lsb_first)
 2fc:	80 91 81 00 	lds	r24, 0x0081
 300:	2f 2f       	mov	r18, r31
 302:	30 e0       	ldi	r19, 0x00	; 0
 304:	40 91 8e 00 	lds	r20, 0x008E
 308:	50 91 8f 00 	lds	r21, 0x008F
 30c:	88 23       	and	r24, r24
 30e:	81 f0       	breq	.+32     	; 0x330 <irmp_store_bit+0xa0>
        {
            irmp_tmp_command |= (((uint16_t) (value)) << (irmp_bit - irmp_param.command_offset));   // CV wants cast
 310:	86 2f       	mov	r24, r22
 312:	90 e0       	ldi	r25, 0x00	; 0
 314:	87 1b       	sub	r24, r23
 316:	91 09       	sbc	r25, r1
 318:	02 c0       	rjmp	.+4      	; 0x31e <irmp_store_bit+0x8e>
 31a:	22 0f       	add	r18, r18
 31c:	33 1f       	adc	r19, r19
 31e:	8a 95       	dec	r24
 320:	e2 f7       	brpl	.-8      	; 0x31a <irmp_store_bit+0x8a>
 322:	42 2b       	or	r20, r18
 324:	53 2b       	or	r21, r19
 326:	50 93 8f 00 	sts	0x008F, r21
 32a:	40 93 8e 00 	sts	0x008E, r20
 32e:	3e c0       	rjmp	.+124    	; 0x3ac <irmp_store_bit+0x11c>
        }
        else
        {
            irmp_tmp_command <<= 1;
            irmp_tmp_command |= value;
 330:	44 0f       	add	r20, r20
 332:	55 1f       	adc	r21, r21
 334:	24 2b       	or	r18, r20
 336:	35 2b       	or	r19, r21
 338:	35 c0       	rjmp	.+106    	; 0x3a4 <irmp_store_bit+0x114>
        irmp_tmp_address2 |= (((uint16_t) (value)) << (irmp_bit - 13));                             // CV wants cast
    }
#endif

#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
    else if (irmp_param.protocol == IRMP_SAMSUNG_PROTOCOL && irmp_bit >= SAMSUNG_ID_OFFSET && irmp_bit < SAMSUNG_ID_OFFSET + SAMSUNG_ID_LEN)
 33a:	80 91 72 00 	lds	r24, 0x0072
 33e:	83 30       	cpi	r24, 0x03	; 3
 340:	d1 f4       	brne	.+52     	; 0x376 <irmp_store_bit+0xe6>
 342:	61 31       	cpi	r22, 0x11	; 17
 344:	98 f1       	brcs	.+102    	; 0x3ac <irmp_store_bit+0x11c>
 346:	65 31       	cpi	r22, 0x15	; 21
 348:	88 f5       	brcc	.+98     	; 0x3ac <irmp_store_bit+0x11c>
    {
        irmp_tmp_id |= (((uint16_t) (value)) << (irmp_bit - SAMSUNG_ID_OFFSET));                    // store with LSB first
 34a:	8f 2f       	mov	r24, r31
 34c:	90 e0       	ldi	r25, 0x00	; 0
 34e:	26 2f       	mov	r18, r22
 350:	30 e0       	ldi	r19, 0x00	; 0
 352:	21 51       	subi	r18, 0x11	; 17
 354:	30 40       	sbci	r19, 0x00	; 0
 356:	02 c0       	rjmp	.+4      	; 0x35c <irmp_store_bit+0xcc>
 358:	88 0f       	add	r24, r24
 35a:	99 1f       	adc	r25, r25
 35c:	2a 95       	dec	r18
 35e:	e2 f7       	brpl	.-8      	; 0x358 <irmp_store_bit+0xc8>
 360:	20 91 90 00 	lds	r18, 0x0090
 364:	30 91 91 00 	lds	r19, 0x0091
 368:	28 2b       	or	r18, r24
 36a:	39 2b       	or	r19, r25
 36c:	30 93 91 00 	sts	0x0091, r19
 370:	20 93 90 00 	sts	0x0090, r18
 374:	1b c0       	rjmp	.+54     	; 0x3ac <irmp_store_bit+0x11c>
    }
#endif

#if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
    else if (irmp_param.protocol == IRMP_KASEIKYO_PROTOCOL && irmp_bit >= 20 && irmp_bit < 24)
 376:	85 30       	cpi	r24, 0x05	; 5
 378:	c9 f4       	brne	.+50     	; 0x3ac <irmp_store_bit+0x11c>
 37a:	64 31       	cpi	r22, 0x14	; 20
 37c:	b8 f0       	brcs	.+46     	; 0x3ac <irmp_store_bit+0x11c>
 37e:	68 31       	cpi	r22, 0x18	; 24
 380:	a8 f4       	brcc	.+42     	; 0x3ac <irmp_store_bit+0x11c>
    {
        irmp_tmp_command |= (((uint16_t) (value)) << (irmp_bit - 8));                   // store 4 system bits in upper nibble with LSB first
 382:	8f 2f       	mov	r24, r31
 384:	90 e0       	ldi	r25, 0x00	; 0
 386:	26 2f       	mov	r18, r22
 388:	30 e0       	ldi	r19, 0x00	; 0
 38a:	28 50       	subi	r18, 0x08	; 8
 38c:	30 40       	sbci	r19, 0x00	; 0
 38e:	02 c0       	rjmp	.+4      	; 0x394 <irmp_store_bit+0x104>
 390:	88 0f       	add	r24, r24
 392:	99 1f       	adc	r25, r25
 394:	2a 95       	dec	r18
 396:	e2 f7       	brpl	.-8      	; 0x390 <irmp_store_bit+0x100>
 398:	20 91 8e 00 	lds	r18, 0x008E
 39c:	30 91 8f 00 	lds	r19, 0x008F
 3a0:	28 2b       	or	r18, r24
 3a2:	39 2b       	or	r19, r25
 3a4:	30 93 8f 00 	sts	0x008F, r19
 3a8:	20 93 8e 00 	sts	0x008E, r18
    }

    if (irmp_param.protocol == IRMP_KASEIKYO_PROTOCOL && irmp_bit < KASEIKYO_COMPLETE_DATA_LEN)
 3ac:	80 91 72 00 	lds	r24, 0x0072
 3b0:	85 30       	cpi	r24, 0x05	; 5
 3b2:	51 f5       	brne	.+84     	; 0x408 <irmp_store_bit+0x178>
 3b4:	60 33       	cpi	r22, 0x30	; 48
 3b6:	40 f5       	brcc	.+80     	; 0x408 <irmp_store_bit+0x178>
 3b8:	26 2f       	mov	r18, r22
 3ba:	30 e0       	ldi	r19, 0x00	; 0
 3bc:	e6 2f       	mov	r30, r22
 3be:	e6 95       	lsr	r30
 3c0:	e6 95       	lsr	r30
 3c2:	e6 95       	lsr	r30
    {
        if (value)
 3c4:	ff 23       	and	r31, r31
 3c6:	81 f0       	breq	.+32     	; 0x3e8 <irmp_store_bit+0x158>
        {
            xor_check[irmp_bit / 8] |= 1 << (irmp_bit % 8);
 3c8:	f0 e0       	ldi	r31, 0x00	; 0
 3ca:	ee 56       	subi	r30, 0x6E	; 110
 3cc:	ff 4f       	sbci	r31, 0xFF	; 255
 3ce:	27 70       	andi	r18, 0x07	; 7
 3d0:	30 70       	andi	r19, 0x00	; 0
 3d2:	81 e0       	ldi	r24, 0x01	; 1
 3d4:	90 e0       	ldi	r25, 0x00	; 0
 3d6:	02 c0       	rjmp	.+4      	; 0x3dc <irmp_store_bit+0x14c>
 3d8:	88 0f       	add	r24, r24
 3da:	99 1f       	adc	r25, r25
 3dc:	2a 95       	dec	r18
 3de:	e2 f7       	brpl	.-8      	; 0x3d8 <irmp_store_bit+0x148>
 3e0:	20 81       	ld	r18, Z
 3e2:	28 2b       	or	r18, r24
 3e4:	20 83       	st	Z, r18
 3e6:	10 c0       	rjmp	.+32     	; 0x408 <irmp_store_bit+0x178>
        }
        else
        {
            xor_check[irmp_bit / 8] &= ~(1 << (irmp_bit % 8));
 3e8:	f0 e0       	ldi	r31, 0x00	; 0
 3ea:	ee 56       	subi	r30, 0x6E	; 110
 3ec:	ff 4f       	sbci	r31, 0xFF	; 255
 3ee:	27 70       	andi	r18, 0x07	; 7
 3f0:	30 70       	andi	r19, 0x00	; 0
 3f2:	81 e0       	ldi	r24, 0x01	; 1
 3f4:	90 e0       	ldi	r25, 0x00	; 0
 3f6:	02 c0       	rjmp	.+4      	; 0x3fc <irmp_store_bit+0x16c>
 3f8:	88 0f       	add	r24, r24
 3fa:	99 1f       	adc	r25, r25
 3fc:	2a 95       	dec	r18
 3fe:	e2 f7       	brpl	.-8      	; 0x3f8 <irmp_store_bit+0x168>
 400:	80 95       	com	r24
 402:	20 81       	ld	r18, Z
 404:	82 23       	and	r24, r18
 406:	80 83       	st	Z, r24
        }
    }

#endif

    irmp_bit++;
 408:	6f 5f       	subi	r22, 0xFF	; 255
 40a:	60 93 71 00 	sts	0x0071, r22
}
 40e:	08 95       	ret

00000410 <timer1_init>:
{
#if defined (__AVR_ATtiny45__) || defined (__AVR_ATtiny85__)                // ATtiny45 / ATtiny85:
    OCR1A   =  (F_CPU / F_INTERRUPTS / 4) - 1;                              // compare value: 1/15000 of CPU frequency, presc = 4
    TCCR1   = (1 << CTC1) | (1 << CS11) | (1 << CS10);                      // switch CTC Mode on, set prescaler to 4
#else                                                                       // ATmegaXX:
    OCR1A   =  (F_CPU / F_INTERRUPTS) - 1;                                  // compare value: 1/15000 of CPU frequency
 410:	86 ed       	ldi	r24, 0xD6	; 214
 412:	93 e0       	ldi	r25, 0x03	; 3
 414:	9b bd       	out	0x2b, r25	; 43
 416:	8a bd       	out	0x2a, r24	; 42
    TCCR1B  = (1 << WGM12) | (1 << CS10);                                   // switch CTC Mode on, set prescaler to 1
 418:	89 e0       	ldi	r24, 0x09	; 9
 41a:	8e bd       	out	0x2e, r24	; 46
#endif

#ifdef TIMSK1
    TIMSK1  = 1 << OCIE1A;                                                  // OCIE1A: Interrupt by timer compare
#else
    TIMSK   = 1 << OCIE1A;                                                  // OCIE1A: Interrupt by timer compare
 41c:	80 e1       	ldi	r24, 0x10	; 16
 41e:	89 bf       	out	0x39, r24	; 57
#endif
}
 420:	08 95       	ret

00000422 <main>:
}


int
main (void)
{
 422:	cf 92       	push	r12
 424:	df 92       	push	r13
 426:	ef 92       	push	r14
 428:	ff 92       	push	r15
 42a:	0f 93       	push	r16
 42c:	1f 93       	push	r17
 42e:	df 93       	push	r29
 430:	cf 93       	push	r28
 432:	00 d0       	rcall	.+0      	; 0x434 <main+0x12>
 434:	00 d0       	rcall	.+0      	; 0x436 <main+0x14>
 436:	00 d0       	rcall	.+0      	; 0x438 <main+0x16>
 438:	cd b7       	in	r28, 0x3d	; 61
 43a:	de b7       	in	r29, 0x3e	; 62
    IRMP_DATA irmp_data;
	
	
	DDRD=0xFF;
 43c:	8f ef       	ldi	r24, 0xFF	; 255
 43e:	81 bb       	out	0x11, r24	; 17
	DDRA=0xFF;
 440:	8a bb       	out	0x1a, r24	; 26
	
	PORTA = 0b11110000;
 442:	80 ef       	ldi	r24, 0xF0	; 240
 444:	8b bb       	out	0x1b, r24	; 27
#ifndef ANALYZE
void
irmp_init (void)
{
#ifndef PIC_CCS_COMPILER
    IRMP_PORT &= ~(1<<IRMP_BIT);                                        // deactivate pullup
 446:	c6 98       	cbi	0x18, 6	; 24
    IRMP_DDR &= ~(1<<IRMP_BIT);                                         // set pin to input
 448:	be 98       	cbi	0x17, 6	; 23
{
#if defined (__AVR_ATtiny45__) || defined (__AVR_ATtiny85__)                // ATtiny45 / ATtiny85:
    OCR1A   =  (F_CPU / F_INTERRUPTS / 4) - 1;                              // compare value: 1/15000 of CPU frequency, presc = 4
    TCCR1   = (1 << CTC1) | (1 << CS11) | (1 << CS10);                      // switch CTC Mode on, set prescaler to 4
#else                                                                       // ATmegaXX:
    OCR1A   =  (F_CPU / F_INTERRUPTS) - 1;                                  // compare value: 1/15000 of CPU frequency
 44a:	86 ed       	ldi	r24, 0xD6	; 214
 44c:	93 e0       	ldi	r25, 0x03	; 3
 44e:	9b bd       	out	0x2b, r25	; 43
 450:	8a bd       	out	0x2a, r24	; 42
    TCCR1B  = (1 << WGM12) | (1 << CS10);                                   // switch CTC Mode on, set prescaler to 1
 452:	89 e0       	ldi	r24, 0x09	; 9
 454:	8e bd       	out	0x2e, r24	; 46
#endif

#ifdef TIMSK1
    TIMSK1  = 1 << OCIE1A;                                                  // OCIE1A: Interrupt by timer compare
#else
    TIMSK   = 1 << OCIE1A;                                                  // OCIE1A: Interrupt by timer compare
 456:	80 e1       	ldi	r24, 0x10	; 16
 458:	89 bf       	out	0x39, r24	; 57
	
	PORTA = 0b11110000;

    irmp_init();                                                            // initialize irmp
    timer1_init();                                                          // initialize timer 1
    sei ();                                                                 // enable interrupts
 45a:	78 94       	sei

    for (;;)
    {
		PORTD = 0b01110111;
 45c:	b7 e7       	ldi	r27, 0x77	; 119
 45e:	cb 2e       	mov	r12, r27
        if (irmp_get_data (&irmp_data))
 460:	7e 01       	movw	r14, r28
 462:	08 94       	sec
 464:	e1 1c       	adc	r14, r1
 466:	f1 1c       	adc	r15, r1
        {
			PORTD = 0b11111111;
 468:	dd 24       	eor	r13, r13
 46a:	da 94       	dec	r13
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 46c:	00 e7       	ldi	r16, 0x70	; 112
 46e:	11 e0       	ldi	r17, 0x01	; 1
    timer1_init();                                                          // initialize timer 1
    sei ();                                                                 // enable interrupts

    for (;;)
    {
		PORTD = 0b01110111;
 470:	c2 ba       	out	0x12, r12	; 18
        if (irmp_get_data (&irmp_data))
 472:	c7 01       	movw	r24, r14
 474:	0e 94 99 00 	call	0x132	; 0x132 <irmp_get_data>
 478:	88 23       	and	r24, r24
 47a:	d1 f3       	breq	.-12     	; 0x470 <main+0x4e>
        {
			PORTD = 0b11111111;
 47c:	d2 ba       	out	0x12, r13	; 18
 47e:	88 e8       	ldi	r24, 0x88	; 136
 480:	93 e1       	ldi	r25, 0x13	; 19
 482:	f8 01       	movw	r30, r16
 484:	31 97       	sbiw	r30, 0x01	; 1
 486:	f1 f7       	brne	.-4      	; 0x484 <main+0x62>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 488:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 48a:	d9 f7       	brne	.-10     	; 0x482 <main+0x60>
 48c:	f1 cf       	rjmp	.-30     	; 0x470 <main+0x4e>

0000048e <irmp_ISR>:

#ifdef ANALYZE
    time_counter++;
#endif

    irmp_input = input(IRMP_PIN);
 48e:	96 b3       	in	r25, 0x16	; 22
    }
#endif // IRMP_USE_CALLBACK == 1

    irmp_log(irmp_input);                                                       // log ir signal, if IRMP_LOGGING defined

    if (! irmp_ir_detected)                                                     // ir code already detected?
 490:	80 91 83 00 	lds	r24, 0x0083
 494:	88 23       	and	r24, r24
 496:	09 f0       	breq	.+2      	; 0x49a <irmp_ISR+0xc>
 498:	e5 c3       	rjmp	.+1994   	; 0xc64 <__stack+0x405>

#ifdef ANALYZE
    time_counter++;
#endif

    irmp_input = input(IRMP_PIN);
 49a:	90 74       	andi	r25, 0x40	; 64

    irmp_log(irmp_input);                                                       // log ir signal, if IRMP_LOGGING defined

    if (! irmp_ir_detected)                                                     // ir code already detected?
    {                                                                           // no...
        if (! irmp_start_bit_detected)                                          // start bit detected?
 49c:	80 91 70 00 	lds	r24, 0x0070
 4a0:	88 23       	and	r24, r24
 4a2:	81 f5       	brne	.+96     	; 0x504 <irmp_ISR+0x76>
 4a4:	80 91 6d 00 	lds	r24, 0x006D
        {                                                                       // no...
            if (! irmp_input)                                                   // receiving burst?
 4a8:	99 23       	and	r25, r25
 4aa:	21 f4       	brne	.+8      	; 0x4b4 <irmp_ISR+0x26>
                if (! irmp_pulse_time)
                {
                    ANALYZE_PRINTF("%8d [starting pulse]\n", time_counter);
                }
#endif
                irmp_pulse_time++;                                              // increment counter
 4ac:	8f 5f       	subi	r24, 0xFF	; 255
 4ae:	80 93 6d 00 	sts	0x006D, r24
 4b2:	d8 c3       	rjmp	.+1968   	; 0xc64 <__stack+0x405>
            }
            else
            {                                                                   // no...
                if (irmp_pulse_time)                                            // it's dark....
 4b4:	88 23       	and	r24, r24
 4b6:	b9 f0       	breq	.+46     	; 0x4e6 <irmp_ISR+0x58>
                {                                                               // set flags for counting the time of darkness...
                    irmp_start_bit_detected = 1;
 4b8:	91 e0       	ldi	r25, 0x01	; 1
 4ba:	90 93 70 00 	sts	0x0070, r25
                    wait_for_start_space    = 1;
 4be:	90 93 6e 00 	sts	0x006E, r25
                    wait_for_space          = 0;
 4c2:	10 92 6f 00 	sts	0x006F, r1
                    irmp_tmp_command        = 0;
 4c6:	10 92 8f 00 	sts	0x008F, r1
 4ca:	10 92 8e 00 	sts	0x008E, r1
                    irmp_tmp_address        = 0;
 4ce:	10 92 8d 00 	sts	0x008D, r1
 4d2:	10 92 8c 00 	sts	0x008C, r1
#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCOL == 1) || IRMP_SUPPORT_NEC42_PROTOCOL == 1
                    irmp_tmp_command2       = 0;
                    irmp_tmp_address2       = 0;
#endif

                    irmp_bit                = 0xff;
 4d6:	8f ef       	ldi	r24, 0xFF	; 255
 4d8:	80 93 71 00 	sts	0x0071, r24
                    irmp_pause_time         = 1;                                // 1st pause: set to 1, not to 0!
 4dc:	90 93 6c 00 	sts	0x006C, r25
#if IRMP_SUPPORT_RC5_PROTOCOL == 1
                    rc5_cmd_bit6            = 0;                                // fm 2010-03-07: bugfix: reset it after incomplete RC5 frame!
 4e0:	10 92 66 00 	sts	0x0066, r1
 4e4:	bf c3       	rjmp	.+1918   	; 0xc64 <__stack+0x405>
#endif
                }
                else
                {
                    if (repetition_len < 0xFFFF)                                // avoid overflow of counter
 4e6:	80 91 6a 00 	lds	r24, 0x006A
 4ea:	90 91 6b 00 	lds	r25, 0x006B
 4ee:	2f ef       	ldi	r18, 0xFF	; 255
 4f0:	8f 3f       	cpi	r24, 0xFF	; 255
 4f2:	92 07       	cpc	r25, r18
 4f4:	09 f4       	brne	.+2      	; 0x4f8 <irmp_ISR+0x6a>
 4f6:	b6 c3       	rjmp	.+1900   	; 0xc64 <__stack+0x405>
                    {
                        repetition_len++;
 4f8:	01 96       	adiw	r24, 0x01	; 1
 4fa:	90 93 6b 00 	sts	0x006B, r25
 4fe:	80 93 6a 00 	sts	0x006A, r24
 502:	b0 c3       	rjmp	.+1888   	; 0xc64 <__stack+0x405>
                }
            }
        }
        else
        {
            if (wait_for_start_space)                                           // we have received start bit...
 504:	80 91 6e 00 	lds	r24, 0x006E
 508:	88 23       	and	r24, r24
 50a:	09 f4       	brne	.+2      	; 0x50e <irmp_ISR+0x80>
 50c:	e4 c0       	rjmp	.+456    	; 0x6d6 <irmp_ISR+0x248>
            {                                                                   // ...and are counting the time of darkness
                if (irmp_input)                                                 // still dark?
 50e:	99 23       	and	r25, r25
 510:	49 f0       	breq	.+18     	; 0x524 <irmp_ISR+0x96>
                {                                                               // yes
                    irmp_pause_time++;                                          // increment counter
 512:	80 91 6c 00 	lds	r24, 0x006C
 516:	8f 5f       	subi	r24, 0xFF	; 255
 518:	80 93 6c 00 	sts	0x006C, r24

#if IRMP_SUPPORT_NIKON_PROTOCOL == 1
                    if (((irmp_pulse_time < NIKON_START_BIT_PULSE_LEN_MIN || irmp_pulse_time > NIKON_START_BIT_PULSE_LEN_MAX) && irmp_pause_time > IRMP_TIMEOUT_LEN) ||
                         irmp_pause_time > IRMP_TIMEOUT_NIKON_LEN)
#else
                    if (irmp_pause_time > IRMP_TIMEOUT_LEN)                     // timeout?
 51c:	89 3f       	cpi	r24, 0xF9	; 249
 51e:	08 f4       	brcc	.+2      	; 0x522 <irmp_ISR+0x94>
 520:	70 c2       	rjmp	.+1248   	; 0xa02 <__stack+0x1a3>
 522:	ad c1       	rjmp	.+858    	; 0x87e <__stack+0x1f>
#endif

                    ANALYZE_PRINTF ("%8d [start-bit: pulse = %2d, pause = %2d]\n", time_counter, irmp_pulse_time, irmp_pause_time);

#if IRMP_SUPPORT_SIRCS_PROTOCOL == 1
                    if (irmp_pulse_time >= SIRCS_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= SIRCS_START_BIT_PULSE_LEN_MAX &&
 524:	20 91 6d 00 	lds	r18, 0x006D
 528:	82 2f       	mov	r24, r18
 52a:	8f 51       	subi	r24, 0x1F	; 31
 52c:	8b 30       	cpi	r24, 0x0B	; 11
 52e:	48 f4       	brcc	.+18     	; 0x542 <irmp_ISR+0xb4>
 530:	80 91 6c 00 	lds	r24, 0x006C
 534:	86 30       	cpi	r24, 0x06	; 6
 536:	28 f0       	brcs	.+10     	; 0x542 <irmp_ISR+0xb4>
 538:	8b 30       	cpi	r24, 0x0B	; 11
 53a:	18 f4       	brcc	.+6      	; 0x542 <irmp_ISR+0xb4>
                        irmp_pause_time >= SIRCS_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= SIRCS_START_BIT_PAUSE_LEN_MAX)
                    {                                                           // it's SIRCS
                        ANALYZE_PRINTF ("protocol = SIRCS, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
                                        SIRCS_START_BIT_PULSE_LEN_MIN, SIRCS_START_BIT_PULSE_LEN_MAX,
                                        SIRCS_START_BIT_PAUSE_LEN_MIN, SIRCS_START_BIT_PAUSE_LEN_MAX);
                        irmp_param_p = (IRMP_PARAMETER *) (IRMP_PARAMETER *) &sircs_param;
 53c:	64 e5       	ldi	r22, 0x54	; 84
 53e:	70 e0       	ldi	r23, 0x00	; 0
 540:	81 c0       	rjmp	.+258    	; 0x644 <irmp_ISR+0x1b6>
                    }
                    else
#endif // IRMP_SUPPORT_JVC_PROTOCOL == 1

#if IRMP_SUPPORT_NEC_PROTOCOL == 1
                    if (irmp_pulse_time >= NEC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NEC_START_BIT_PULSE_LEN_MAX &&
 542:	82 2f       	mov	r24, r18
 544:	80 55       	subi	r24, 0x50	; 80
 546:	8f 36       	cpi	r24, 0x6F	; 111
 548:	80 f4       	brcc	.+32     	; 0x56a <irmp_ISR+0xdc>
 54a:	80 91 6c 00 	lds	r24, 0x006C
 54e:	88 32       	cpi	r24, 0x28	; 40
 550:	28 f0       	brcs	.+10     	; 0x55c <irmp_ISR+0xce>
 552:	81 36       	cpi	r24, 0x61	; 97
 554:	28 f4       	brcc	.+10     	; 0x560 <irmp_ISR+0xd2>
                        irmp_param_p = (IRMP_PARAMETER *) &nec42_param;
#else
                        ANALYZE_PRINTF ("protocol = NEC, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
                                        NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX,
                                        NEC_START_BIT_PAUSE_LEN_MIN, NEC_START_BIT_PAUSE_LEN_MAX);
                        irmp_param_p = (IRMP_PARAMETER *) &nec_param;
 556:	65 e6       	ldi	r22, 0x65	; 101
 558:	70 e0       	ldi	r23, 0x00	; 0
 55a:	74 c0       	rjmp	.+232    	; 0x644 <irmp_ISR+0x1b6>
#endif

                    }
                    else if (irmp_pulse_time >= NEC_START_BIT_PULSE_LEN_MIN        && irmp_pulse_time <= NEC_START_BIT_PULSE_LEN_MAX &&
 55c:	83 31       	cpi	r24, 0x13	; 19
 55e:	28 f0       	brcs	.+10     	; 0x56a <irmp_ISR+0xdc>
 560:	81 33       	cpi	r24, 0x31	; 49
 562:	18 f4       	brcc	.+6      	; 0x56a <irmp_ISR+0xdc>
                    {                                                           // it's NEC
                        ANALYZE_PRINTF ("protocol = NEC (repetition frame), start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
                                        NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX,
                                        NEC_REPEAT_START_BIT_PAUSE_LEN_MIN, NEC_REPEAT_START_BIT_PAUSE_LEN_MAX);

                        irmp_param_p = (IRMP_PARAMETER *) &nec_rep_param;
 564:	66 e7       	ldi	r22, 0x76	; 118
 566:	70 e0       	ldi	r23, 0x00	; 0
 568:	6d c0       	rjmp	.+218    	; 0x644 <irmp_ISR+0x1b6>
                    }
                    else
#endif // IRMP_SUPPORT_NIKON_PROTOCOL == 1

#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
                    if (irmp_pulse_time >= SAMSUNG_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= SAMSUNG_START_BIT_PULSE_LEN_MAX &&
 56a:	82 2f       	mov	r24, r18
 56c:	8c 53       	subi	r24, 0x3C	; 60
 56e:	80 31       	cpi	r24, 0x10	; 16
 570:	48 f4       	brcc	.+18     	; 0x584 <irmp_ISR+0xf6>
 572:	80 91 6c 00 	lds	r24, 0x006C
 576:	8c 33       	cpi	r24, 0x3C	; 60
 578:	28 f0       	brcs	.+10     	; 0x584 <irmp_ISR+0xf6>
 57a:	8c 34       	cpi	r24, 0x4C	; 76
 57c:	18 f4       	brcc	.+6      	; 0x584 <irmp_ISR+0xf6>
                        irmp_pause_time >= SAMSUNG_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= SAMSUNG_START_BIT_PAUSE_LEN_MAX)
                    {                                                           // it's SAMSUNG
                        ANALYZE_PRINTF ("protocol = SAMSUNG, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
                                        SAMSUNG_START_BIT_PULSE_LEN_MIN, SAMSUNG_START_BIT_PULSE_LEN_MAX,
                                        SAMSUNG_START_BIT_PAUSE_LEN_MIN, SAMSUNG_START_BIT_PAUSE_LEN_MAX);
                        irmp_param_p = (IRMP_PARAMETER *) &samsung_param;
 57e:	67 e8       	ldi	r22, 0x87	; 135
 580:	70 e0       	ldi	r23, 0x00	; 0
 582:	60 c0       	rjmp	.+192    	; 0x644 <irmp_ISR+0x1b6>
                    }
                    else
#endif // IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1

#if IRMP_SUPPORT_MATSUSHITA_PROTOCOL == 1
                    if (irmp_pulse_time >= MATSUSHITA_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= MATSUSHITA_START_BIT_PULSE_LEN_MAX &&
 584:	82 2f       	mov	r24, r18
 586:	89 52       	subi	r24, 0x29	; 41
 588:	88 31       	cpi	r24, 0x18	; 24
 58a:	48 f4       	brcc	.+18     	; 0x59e <irmp_ISR+0x110>
 58c:	80 91 6c 00 	lds	r24, 0x006C
 590:	89 32       	cpi	r24, 0x29	; 41
 592:	28 f0       	brcs	.+10     	; 0x59e <irmp_ISR+0x110>
 594:	81 34       	cpi	r24, 0x41	; 65
 596:	18 f4       	brcc	.+6      	; 0x59e <irmp_ISR+0x110>
                        irmp_pause_time >= MATSUSHITA_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= MATSUSHITA_START_BIT_PAUSE_LEN_MAX)
                    {                                                           // it's MATSUSHITA
                        ANALYZE_PRINTF ("protocol = MATSUSHITA, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
                                        MATSUSHITA_START_BIT_PULSE_LEN_MIN, MATSUSHITA_START_BIT_PULSE_LEN_MAX,
                                        MATSUSHITA_START_BIT_PAUSE_LEN_MIN, MATSUSHITA_START_BIT_PAUSE_LEN_MAX);
                        irmp_param_p = (IRMP_PARAMETER *) &matsushita_param;
 598:	68 e9       	ldi	r22, 0x98	; 152
 59a:	70 e0       	ldi	r23, 0x00	; 0
 59c:	53 c0       	rjmp	.+166    	; 0x644 <irmp_ISR+0x1b6>
                    }
                    else
#endif // IRMP_SUPPORT_MATSUSHITA_PROTOCOL == 1

#if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
                    if (irmp_pulse_time >= KASEIKYO_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= KASEIKYO_START_BIT_PULSE_LEN_MAX &&
 59e:	82 2f       	mov	r24, r18
 5a0:	8d 52       	subi	r24, 0x2D	; 45
 5a2:	8d 30       	cpi	r24, 0x0D	; 13
 5a4:	48 f4       	brcc	.+18     	; 0x5b8 <irmp_ISR+0x12a>
 5a6:	80 91 6c 00 	lds	r24, 0x006C
 5aa:	86 31       	cpi	r24, 0x16	; 22
 5ac:	28 f0       	brcs	.+10     	; 0x5b8 <irmp_ISR+0x12a>
 5ae:	8e 31       	cpi	r24, 0x1E	; 30
 5b0:	18 f4       	brcc	.+6      	; 0x5b8 <irmp_ISR+0x12a>
                        irmp_pause_time >= KASEIKYO_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= KASEIKYO_START_BIT_PAUSE_LEN_MAX)
                    {                                                           // it's KASEIKYO
                        ANALYZE_PRINTF ("protocol = KASEIKYO, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
                                        KASEIKYO_START_BIT_PULSE_LEN_MIN, KASEIKYO_START_BIT_PULSE_LEN_MAX,
                                        KASEIKYO_START_BIT_PAUSE_LEN_MIN, KASEIKYO_START_BIT_PAUSE_LEN_MAX);
                        irmp_param_p = (IRMP_PARAMETER *) &kaseikyo_param;
 5b2:	69 ea       	ldi	r22, 0xA9	; 169
 5b4:	70 e0       	ldi	r23, 0x00	; 0
 5b6:	46 c0       	rjmp	.+140    	; 0x644 <irmp_ISR+0x1b6>
                    }
                    else
#endif // IRMP_SUPPORT_RECS80_PROTOCOL == 1

#if IRMP_SUPPORT_RC5_PROTOCOL == 1
                    if (((irmp_pulse_time >= RC5_START_BIT_LEN_MIN     && irmp_pulse_time <= RC5_START_BIT_LEN_MAX) ||
 5b8:	82 2f       	mov	r24, r18
 5ba:	8b 50       	subi	r24, 0x0B	; 11
 5bc:	86 30       	cpi	r24, 0x06	; 6
 5be:	18 f0       	brcs	.+6      	; 0x5c6 <irmp_ISR+0x138>
 5c0:	8b 50       	subi	r24, 0x0B	; 11
 5c2:	8b 30       	cpi	r24, 0x0B	; 11
 5c4:	c8 f4       	brcc	.+50     	; 0x5f8 <irmp_ISR+0x16a>
 5c6:	90 91 6c 00 	lds	r25, 0x006C
 5ca:	89 2f       	mov	r24, r25
 5cc:	8b 50       	subi	r24, 0x0B	; 11
 5ce:	86 30       	cpi	r24, 0x06	; 6
 5d0:	18 f0       	brcs	.+6      	; 0x5d8 <irmp_ISR+0x14a>
 5d2:	8b 50       	subi	r24, 0x0B	; 11
 5d4:	8b 30       	cpi	r24, 0x0B	; 11
 5d6:	80 f4       	brcc	.+32     	; 0x5f8 <irmp_ISR+0x16a>
                                            2 * RC5_START_BIT_LEN_MIN, 2 * RC5_START_BIT_LEN_MAX,
                                            RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX,
                                            2 * RC5_START_BIT_LEN_MIN, 2 * RC5_START_BIT_LEN_MAX);
                        }

                        irmp_param_p = (IRMP_PARAMETER *) &rc5_param;
 5d8:	6a eb       	ldi	r22, 0xBA	; 186
 5da:	70 e0       	ldi	r23, 0x00	; 0
                        last_pause = irmp_pause_time;
 5dc:	90 93 65 00 	sts	0x0065, r25

                        if ((irmp_pulse_time > RC5_START_BIT_LEN_MAX && irmp_pulse_time <= 2 * RC5_START_BIT_LEN_MAX) ||
 5e0:	21 51       	subi	r18, 0x11	; 17
 5e2:	20 31       	cpi	r18, 0x10	; 16
 5e4:	18 f0       	brcs	.+6      	; 0x5ec <irmp_ISR+0x15e>
 5e6:	91 51       	subi	r25, 0x11	; 17
 5e8:	90 31       	cpi	r25, 0x10	; 16
 5ea:	20 f5       	brcc	.+72     	; 0x634 <irmp_ISR+0x1a6>
                            (irmp_pause_time > RC5_START_BIT_LEN_MAX && irmp_pause_time <= 2 * RC5_START_BIT_LEN_MAX))
                        {
                          last_value  = 0;
 5ec:	10 92 64 00 	sts	0x0064, r1
                          rc5_cmd_bit6 = 1<<6;
 5f0:	80 e4       	ldi	r24, 0x40	; 64
 5f2:	80 93 66 00 	sts	0x0066, r24
 5f6:	26 c0       	rjmp	.+76     	; 0x644 <irmp_ISR+0x1b6>
                    }
                    else
#endif // IRMP_SUPPORT_RC5_PROTOCOL == 1

#if IRMP_SUPPORT_DENON_PROTOCOL == 1
                    if ( (irmp_pulse_time >= DENON_PULSE_LEN_MIN && irmp_pulse_time <= DENON_PULSE_LEN_MAX) &&
 5f8:	23 50       	subi	r18, 0x03	; 3
 5fa:	24 30       	cpi	r18, 0x04	; 4
 5fc:	60 f4       	brcc	.+24     	; 0x616 <irmp_ISR+0x188>
 5fe:	90 91 6c 00 	lds	r25, 0x006C
 602:	89 2f       	mov	r24, r25
 604:	87 51       	subi	r24, 0x17	; 23
 606:	88 30       	cpi	r24, 0x08	; 8
 608:	18 f0       	brcs	.+6      	; 0x610 <irmp_ISR+0x182>
 60a:	9a 50       	subi	r25, 0x0A	; 10
 60c:	94 30       	cpi	r25, 0x04	; 4
 60e:	18 f4       	brcc	.+6      	; 0x616 <irmp_ISR+0x188>
                    {                                                           // it's DENON
                        ANALYZE_PRINTF ("protocol = DENON, start bit timings: pulse: %3d - %3d, pause: %3d - %3d or %3d - %3d\n",
                                        DENON_PULSE_LEN_MIN, DENON_PULSE_LEN_MAX,
                                        DENON_1_PAUSE_LEN_MIN, DENON_1_PAUSE_LEN_MAX,
                                        DENON_0_PAUSE_LEN_MIN, DENON_0_PAUSE_LEN_MAX);
                        irmp_param_p = (IRMP_PARAMETER *) &denon_param;
 610:	6b ec       	ldi	r22, 0xCB	; 203
 612:	70 e0       	ldi	r23, 0x00	; 0
 614:	17 c0       	rjmp	.+46     	; 0x644 <irmp_ISR+0x1b6>
                    }
                    else
#endif // IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1

#if IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
                    if (((irmp_pulse_time >= SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MAX) ||
 616:	2a 30       	cpi	r18, 0x0A	; 10
 618:	88 f4       	brcc	.+34     	; 0x63c <irmp_ISR+0x1ae>
 61a:	90 91 6c 00 	lds	r25, 0x006C
 61e:	89 2f       	mov	r24, r25
 620:	86 50       	subi	r24, 0x06	; 6
 622:	85 30       	cpi	r24, 0x05	; 5
 624:	18 f0       	brcs	.+6      	; 0x62c <irmp_ISR+0x19e>
 626:	86 50       	subi	r24, 0x06	; 6
 628:	89 30       	cpi	r24, 0x09	; 9
 62a:	40 f4       	brcc	.+16     	; 0x63c <irmp_ISR+0x1ae>
                        ANALYZE_PRINTF ("protocol = RUWIDO, start bit timings: pulse: %3d - %3d or %3d - %3d, pause: %3d - %3d or %3d - %3d\n",
                                        SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN,   SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MAX,
                                        2 * SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN, 2 * SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MAX,
                                        SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN,   SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MAX,
                                        2 * SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN, 2 * SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MAX);
                        irmp_param_p = (IRMP_PARAMETER *) &ruwido_param;
 62c:	6c ed       	ldi	r22, 0xDC	; 220
 62e:	70 e0       	ldi	r23, 0x00	; 0
                        last_pause = irmp_pause_time;
 630:	90 93 65 00 	sts	0x0065, r25
                        last_value  = 1;
 634:	81 e0       	ldi	r24, 0x01	; 1
 636:	80 93 64 00 	sts	0x0064, r24
 63a:	04 c0       	rjmp	.+8      	; 0x644 <irmp_ISR+0x1b6>
#endif // IRMP_SUPPORT_NEC_PROTOCOL == 1

                    {
                        ANALYZE_PRINTF ("protocol = UNKNOWN\n");
//                      irmp_busy_flag = FALSE;
                        irmp_start_bit_detected = 0;                            // wait for another start bit...
 63c:	10 92 70 00 	sts	0x0070, r1
 640:	60 e0       	ldi	r22, 0x00	; 0
 642:	70 e0       	ldi	r23, 0x00	; 0
                    }

                    if (irmp_start_bit_detected)
 644:	80 91 70 00 	lds	r24, 0x0070
 648:	88 23       	and	r24, r24
 64a:	31 f0       	breq	.+12     	; 0x658 <irmp_ISR+0x1ca>
                    {
                        memcpy_P (&irmp_param, irmp_param_p, sizeof (IRMP_PARAMETER));
 64c:	82 e7       	ldi	r24, 0x72	; 114
 64e:	90 e0       	ldi	r25, 0x00	; 0
 650:	41 e1       	ldi	r20, 0x11	; 17
 652:	50 e0       	ldi	r21, 0x00	; 0
 654:	0e 94 59 06 	call	0xcb2	; 0xcb2 <memcpy_P>
                        ANALYZE_PRINTF ("complete_len:   %3d\n", irmp_param.complete_len);
                        ANALYZE_PRINTF ("stop_bit:       %3d\n", irmp_param.stop_bit);
#endif // ANALYZE
                    }

                    irmp_bit = 0;
 658:	10 92 71 00 	sts	0x0071, r1

#if IRMP_SUPPORT_MANCHESTER == 1
                    if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER) &&
 65c:	80 91 82 00 	lds	r24, 0x0082
 660:	48 2f       	mov	r20, r24
 662:	50 e0       	ldi	r21, 0x00	; 0
 664:	80 ff       	sbrs	r24, 0
 666:	21 c0       	rjmp	.+66     	; 0x6aa <irmp_ISR+0x21c>
 668:	80 91 72 00 	lds	r24, 0x0072
 66c:	87 31       	cpi	r24, 0x17	; 23
 66e:	e9 f0       	breq	.+58     	; 0x6aa <irmp_ISR+0x21c>
 670:	89 30       	cpi	r24, 0x09	; 9
 672:	d9 f0       	breq	.+54     	; 0x6aa <irmp_ISR+0x21c>
                         irmp_param.protocol != IRMP_RUWIDO_PROTOCOL && // Manchester, but not RUWIDO
                         irmp_param.protocol != IRMP_RC6_PROTOCOL)      // Manchester, but not RC6
                    {
                        if (irmp_pause_time > irmp_param.pulse_1_len_max && irmp_pause_time <= 2 * irmp_param.pulse_1_len_max)
 674:	20 91 6c 00 	lds	r18, 0x006C
 678:	80 91 74 00 	lds	r24, 0x0074
 67c:	82 17       	cp	r24, r18
 67e:	60 f4       	brcc	.+24     	; 0x698 <irmp_ISR+0x20a>
 680:	30 e0       	ldi	r19, 0x00	; 0
 682:	90 e0       	ldi	r25, 0x00	; 0
 684:	88 0f       	add	r24, r24
 686:	99 1f       	adc	r25, r25
 688:	82 17       	cp	r24, r18
 68a:	93 07       	cpc	r25, r19
 68c:	2c f0       	brlt	.+10     	; 0x698 <irmp_ISR+0x20a>
                        {
                            ANALYZE_PRINTF ("%8d [bit %2d: pulse = %3d, pause = %3d] ", time_counter, irmp_bit, irmp_pulse_time, irmp_pause_time);
                            ANALYZE_PUTCHAR ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? '0' : '1');
                            ANALYZE_NEWLINE ();
                            irmp_store_bit ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 0 : 1);
 68e:	56 95       	lsr	r21
 690:	47 95       	ror	r20
 692:	84 2f       	mov	r24, r20
 694:	80 95       	com	r24
 696:	07 c0       	rjmp	.+14     	; 0x6a6 <irmp_ISR+0x218>
                        }
                        else if (! last_value)  // && irmp_pause_time >= irmp_param.pause_1_len_min && irmp_pause_time <= irmp_param.pause_1_len_max)
 698:	80 91 64 00 	lds	r24, 0x0064
 69c:	88 23       	and	r24, r24
 69e:	99 f4       	brne	.+38     	; 0x6c6 <irmp_ISR+0x238>
                        {
                            ANALYZE_PRINTF ("%8d [bit %2d: pulse = %3d, pause = %3d] ", time_counter, irmp_bit, irmp_pulse_time, irmp_pause_time);

                            ANALYZE_PUTCHAR ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? '1' : '0');
                            ANALYZE_NEWLINE ();
                            irmp_store_bit ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 1 : 0);
 6a0:	56 95       	lsr	r21
 6a2:	47 95       	ror	r20
 6a4:	84 2f       	mov	r24, r20
 6a6:	81 70       	andi	r24, 0x01	; 1
 6a8:	0c c0       	rjmp	.+24     	; 0x6c2 <irmp_ISR+0x234>
                    else
#endif // IRMP_SUPPORT_SERIAL == 1


#if IRMP_SUPPORT_DENON_PROTOCOL == 1
                    if (irmp_param.protocol == IRMP_DENON_PROTOCOL)
 6aa:	80 91 72 00 	lds	r24, 0x0072
 6ae:	88 30       	cpi	r24, 0x08	; 8
 6b0:	51 f4       	brne	.+20     	; 0x6c6 <irmp_ISR+0x238>
                    {
                        ANALYZE_PRINTF ("%8d [bit %2d: pulse = %3d, pause = %3d] ", time_counter, irmp_bit, irmp_pulse_time, irmp_pause_time);

                        if (irmp_pause_time >= DENON_1_PAUSE_LEN_MIN && irmp_pause_time <= DENON_1_PAUSE_LEN_MAX)
 6b2:	80 91 6c 00 	lds	r24, 0x006C
 6b6:	87 51       	subi	r24, 0x17	; 23
 6b8:	88 30       	cpi	r24, 0x08	; 8
 6ba:	10 f4       	brcc	.+4      	; 0x6c0 <irmp_ISR+0x232>
                        {                                                       // pause timings correct for "1"?
                          ANALYZE_PUTCHAR ('1');                                  // yes, store 1
                          ANALYZE_NEWLINE ();
                          irmp_store_bit (1);
 6bc:	81 e0       	ldi	r24, 0x01	; 1
 6be:	01 c0       	rjmp	.+2      	; 0x6c2 <irmp_ISR+0x234>
                        }
                        else // if (irmp_pause_time >= DENON_0_PAUSE_LEN_MIN && irmp_pause_time <= DENON_0_PAUSE_LEN_MAX)
                        {                                                       // pause timings correct for "0"?
                          ANALYZE_PUTCHAR ('0');                                  // yes, store 0
                          ANALYZE_NEWLINE ();
                          irmp_store_bit (0);
 6c0:	80 e0       	ldi	r24, 0x00	; 0
 6c2:	0e 94 48 01 	call	0x290	; 0x290 <irmp_store_bit>
#endif // IRMP_SUPPORT_THOMSON_PROTOCOL == 1
                    {
                        ;                                                       // else do nothing
                    }

                    irmp_pulse_time = 1;                                        // set counter to 1, not 0
 6c6:	81 e0       	ldi	r24, 0x01	; 1
 6c8:	80 93 6d 00 	sts	0x006D, r24
                    irmp_pause_time = 0;
 6cc:	10 92 6c 00 	sts	0x006C, r1
                    wait_for_start_space = 0;
 6d0:	10 92 6e 00 	sts	0x006E, r1
 6d4:	96 c1       	rjmp	.+812    	; 0xa02 <__stack+0x1a3>
                }
            }
            else if (wait_for_space)                                            // the data section....
 6d6:	80 91 6f 00 	lds	r24, 0x006F
 6da:	88 23       	and	r24, r24
 6dc:	09 f4       	brne	.+2      	; 0x6e0 <irmp_ISR+0x252>
 6de:	84 c1       	rjmp	.+776    	; 0x9e8 <__stack+0x189>
            {                                                                   // counting the time of darkness....
                uint8_t got_light = FALSE;

                if (irmp_input)                                                 // still dark?
 6e0:	99 23       	and	r25, r25
 6e2:	09 f4       	brne	.+2      	; 0x6e6 <irmp_ISR+0x258>
 6e4:	d3 c0       	rjmp	.+422    	; 0x88c <__stack+0x2d>
                {                                                               // yes...
                    if (irmp_bit == irmp_param.complete_len && irmp_param.stop_bit == 1)
 6e6:	40 91 71 00 	lds	r20, 0x0071
 6ea:	60 91 7f 00 	lds	r22, 0x007F
 6ee:	46 17       	cp	r20, r22
 6f0:	b9 f4       	brne	.+46     	; 0x720 <irmp_ISR+0x292>
 6f2:	80 91 80 00 	lds	r24, 0x0080
 6f6:	81 30       	cpi	r24, 0x01	; 1
 6f8:	99 f4       	brne	.+38     	; 0x720 <irmp_ISR+0x292>
                    {
                        if (
 6fa:	80 91 82 00 	lds	r24, 0x0082
 6fe:	80 fd       	sbrc	r24, 0
 700:	0c c0       	rjmp	.+24     	; 0x71a <irmp_ISR+0x28c>
 702:	90 91 6d 00 	lds	r25, 0x006D
 706:	80 91 77 00 	lds	r24, 0x0077
 70a:	98 17       	cp	r25, r24
 70c:	08 f4       	brcc	.+2      	; 0x710 <irmp_ISR+0x282>
 70e:	b7 c0       	rjmp	.+366    	; 0x87e <__stack+0x1f>
 710:	80 91 78 00 	lds	r24, 0x0078
 714:	89 17       	cp	r24, r25
 716:	08 f4       	brcc	.+2      	; 0x71a <irmp_ISR+0x28c>
 718:	b2 c0       	rjmp	.+356    	; 0x87e <__stack+0x1f>
                            if (! (irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER))
                            {
                                ANALYZE_PRINTF ("stop bit detected\n");
                            }
#endif
                            irmp_param.stop_bit = 0;
 71a:	10 92 80 00 	sts	0x0080, r1
 71e:	71 c1       	rjmp	.+738    	; 0xa02 <__stack+0x1a3>
                            irmp_pause_time         = 0;
                        }
                    }
                    else
                    {
                        irmp_pause_time++;                                                          // increment counter
 720:	50 91 6c 00 	lds	r21, 0x006C
 724:	5f 5f       	subi	r21, 0xFF	; 255
 726:	50 93 6c 00 	sts	0x006C, r21

#if IRMP_SUPPORT_SIRCS_PROTOCOL == 1
                        if (irmp_param.protocol == IRMP_SIRCS_PROTOCOL &&                           // Sony has a variable number of bits:
 72a:	80 91 72 00 	lds	r24, 0x0072
 72e:	81 30       	cpi	r24, 0x01	; 1
 730:	21 f5       	brne	.+72     	; 0x77a <irmp_ISR+0x2ec>
 732:	5c 30       	cpi	r21, 0x0C	; 12
 734:	08 f4       	brcc	.+2      	; 0x738 <irmp_ISR+0x2aa>
 736:	72 c0       	rjmp	.+228    	; 0x81c <irmp_ISR+0x38e>
 738:	4b 30       	cpi	r20, 0x0B	; 11
 73a:	08 f4       	brcc	.+2      	; 0x73e <irmp_ISR+0x2b0>
 73c:	6f c0       	rjmp	.+222    	; 0x81c <irmp_ISR+0x38e>
                            irmp_pause_time > SIRCS_PAUSE_LEN_MAX &&                                // minimum is 12
                            irmp_bit >= 12 - 1)                                                     // pause too long?
                        {                                                                           // yes, break and close this frame
                            irmp_param.complete_len = irmp_bit + 1;                                 // set new complete length
 73e:	4f 5f       	subi	r20, 0xFF	; 255
 740:	40 93 7f 00 	sts	0x007F, r20
 744:	41 50       	subi	r20, 0x01	; 1
                            got_light = TRUE;                                                       // this is a lie, but helps (generates stop bit)
                            irmp_tmp_address |= (irmp_bit - SIRCS_MINIMUM_DATA_LEN + 1) << 8;       // new: store number of additional bits in upper byte of address!
 746:	24 2f       	mov	r18, r20
 748:	30 e0       	ldi	r19, 0x00	; 0
 74a:	2b 50       	subi	r18, 0x0B	; 11
 74c:	30 40       	sbci	r19, 0x00	; 0
 74e:	32 2f       	mov	r19, r18
 750:	22 27       	eor	r18, r18
 752:	80 91 8c 00 	lds	r24, 0x008C
 756:	90 91 8d 00 	lds	r25, 0x008D
 75a:	82 2b       	or	r24, r18
 75c:	93 2b       	or	r25, r19
 75e:	90 93 8d 00 	sts	0x008D, r25
 762:	80 93 8c 00 	sts	0x008C, r24
                            irmp_param.command_end = irmp_param.command_offset + irmp_bit + 1;      // correct command length
 766:	80 91 7d 00 	lds	r24, 0x007D
 76a:	48 0f       	add	r20, r24
 76c:	4f 5f       	subi	r20, 0xFF	; 255
 76e:	40 93 7e 00 	sts	0x007E, r20
                            irmp_pause_time = SIRCS_PAUSE_LEN_MAX - 1;                              // correct pause length
 772:	8a e0       	ldi	r24, 0x0A	; 10
 774:	80 93 6c 00 	sts	0x006C, r24
 778:	89 c0       	rjmp	.+274    	; 0x88c <__stack+0x2d>
                            }
                        }
                        else
#endif
#if IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
                        if (irmp_param.protocol == IRMP_RUWIDO_PROTOCOL && !irmp_param.stop_bit)
 77a:	87 31       	cpi	r24, 0x17	; 23
 77c:	09 f0       	breq	.+2      	; 0x780 <irmp_ISR+0x2f2>
 77e:	4e c0       	rjmp	.+156    	; 0x81c <irmp_ISR+0x38e>
 780:	80 91 80 00 	lds	r24, 0x0080
 784:	88 23       	and	r24, r24
 786:	09 f0       	breq	.+2      	; 0x78a <irmp_ISR+0x2fc>
 788:	49 c0       	rjmp	.+146    	; 0x81c <irmp_ISR+0x38e>
                        {
                            if (irmp_pause_time >= 2 * irmp_param.pause_1_len_max && irmp_bit >= RUWIDO_COMPLETE_DATA_LEN - 2)
 78a:	25 2f       	mov	r18, r21
 78c:	30 e0       	ldi	r19, 0x00	; 0
 78e:	80 91 76 00 	lds	r24, 0x0076
 792:	90 e0       	ldi	r25, 0x00	; 0
 794:	88 0f       	add	r24, r24
 796:	99 1f       	adc	r25, r25
 798:	28 17       	cp	r18, r24
 79a:	39 07       	cpc	r19, r25
 79c:	34 f0       	brlt	.+12     	; 0x7aa <irmp_ISR+0x31c>
 79e:	4f 30       	cpi	r20, 0x0F	; 15
 7a0:	20 f0       	brcs	.+8      	; 0x7aa <irmp_ISR+0x31c>
                            {                                                           // special manchester decoder
                                irmp_param.complete_len = RUWIDO_COMPLETE_DATA_LEN;     // correct complete len
 7a2:	81 e1       	ldi	r24, 0x11	; 17
 7a4:	80 93 7f 00 	sts	0x007F, r24
 7a8:	53 c0       	rjmp	.+166    	; 0x850 <irmp_ISR+0x3c2>
                                got_light = TRUE;                                       // this is a lie, but generates a stop bit ;-)
                                irmp_param.stop_bit = TRUE;                             // set flag
                            }
                            else if (irmp_bit >= RUWIDO_COMPLETE_DATA_LEN)
 7aa:	41 31       	cpi	r20, 0x11	; 17
 7ac:	08 f4       	brcc	.+2      	; 0x7b0 <irmp_ISR+0x322>
 7ae:	29 c1       	rjmp	.+594    	; 0xa02 <__stack+0x1a3>
                            {
                                ANALYZE_PRINTF ("Switching to SIEMENS protocol\n");
                                irmp_param.protocol         = IRMP_SIEMENS_PROTOCOL;    // change protocol
 7b0:	81 e1       	ldi	r24, 0x11	; 17
 7b2:	80 93 72 00 	sts	0x0072, r24
                                irmp_param.address_offset   = SIEMENS_ADDRESS_OFFSET;
 7b6:	10 92 7b 00 	sts	0x007B, r1
                                irmp_param.address_end      = SIEMENS_ADDRESS_OFFSET + SIEMENS_ADDRESS_LEN;
 7ba:	8b e0       	ldi	r24, 0x0B	; 11
 7bc:	80 93 7c 00 	sts	0x007C, r24
                                irmp_param.command_offset   = SIEMENS_COMMAND_OFFSET;
 7c0:	80 93 7d 00 	sts	0x007D, r24
                                irmp_param.command_end      = SIEMENS_COMMAND_OFFSET + SIEMENS_COMMAND_LEN;
 7c4:	86 e1       	ldi	r24, 0x16	; 22
 7c6:	80 93 7e 00 	sts	0x007E, r24

                                //                   76543210
                                // RUWIDO:  AAAAAAAAACCCCCCCp
                                // SIEMENS: AAAAAAAAAAACCCCCCCCCCp
                                irmp_tmp_address <<= 2;
 7ca:	40 91 8c 00 	lds	r20, 0x008C
 7ce:	50 91 8d 00 	lds	r21, 0x008D
 7d2:	44 0f       	add	r20, r20
 7d4:	55 1f       	adc	r21, r21
 7d6:	44 0f       	add	r20, r20
 7d8:	55 1f       	adc	r21, r21
                                irmp_tmp_address |= (irmp_tmp_command >> 6);
 7da:	20 91 8e 00 	lds	r18, 0x008E
 7de:	30 91 8f 00 	lds	r19, 0x008F
 7e2:	c9 01       	movw	r24, r18
 7e4:	a6 e0       	ldi	r26, 0x06	; 6
 7e6:	96 95       	lsr	r25
 7e8:	87 95       	ror	r24
 7ea:	aa 95       	dec	r26
 7ec:	e1 f7       	brne	.-8      	; 0x7e6 <irmp_ISR+0x358>
 7ee:	84 2b       	or	r24, r20
 7f0:	95 2b       	or	r25, r21
 7f2:	90 93 8d 00 	sts	0x008D, r25
 7f6:	80 93 8c 00 	sts	0x008C, r24
                                irmp_tmp_command &= 0x003F;
                                irmp_tmp_command <<= 4;
 7fa:	2f 73       	andi	r18, 0x3F	; 63
 7fc:	30 70       	andi	r19, 0x00	; 0
 7fe:	f4 e0       	ldi	r31, 0x04	; 4
 800:	22 0f       	add	r18, r18
 802:	33 1f       	adc	r19, r19
 804:	fa 95       	dec	r31
 806:	e1 f7       	brne	.-8      	; 0x800 <irmp_ISR+0x372>
                                irmp_tmp_command |= last_value;
 808:	80 91 64 00 	lds	r24, 0x0064
 80c:	90 e0       	ldi	r25, 0x00	; 0
 80e:	28 2b       	or	r18, r24
 810:	39 2b       	or	r19, r25
 812:	30 93 8f 00 	sts	0x008F, r19
 816:	20 93 8e 00 	sts	0x008E, r18
 81a:	f3 c0       	rjmp	.+486    	; 0xa02 <__stack+0x1a3>
                            }
                        }
                        else
#endif
#if IRMP_SUPPORT_MANCHESTER == 1
                        if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER) &&
 81c:	80 91 82 00 	lds	r24, 0x0082
 820:	80 ff       	sbrs	r24, 0
 822:	1a c0       	rjmp	.+52     	; 0x858 <irmp_ISR+0x3ca>
 824:	25 2f       	mov	r18, r21
 826:	30 e0       	ldi	r19, 0x00	; 0
 828:	80 91 76 00 	lds	r24, 0x0076
 82c:	90 e0       	ldi	r25, 0x00	; 0
 82e:	88 0f       	add	r24, r24
 830:	99 1f       	adc	r25, r25
 832:	28 17       	cp	r18, r24
 834:	39 07       	cpc	r19, r25
 836:	84 f0       	brlt	.+32     	; 0x858 <irmp_ISR+0x3ca>
 838:	24 2f       	mov	r18, r20
 83a:	30 e0       	ldi	r19, 0x00	; 0
 83c:	86 2f       	mov	r24, r22
 83e:	90 e0       	ldi	r25, 0x00	; 0
 840:	02 97       	sbiw	r24, 0x02	; 2
 842:	28 17       	cp	r18, r24
 844:	39 07       	cpc	r19, r25
 846:	44 f0       	brlt	.+16     	; 0x858 <irmp_ISR+0x3ca>
 848:	80 91 80 00 	lds	r24, 0x0080
 84c:	88 23       	and	r24, r24
 84e:	21 f4       	brne	.+8      	; 0x858 <irmp_ISR+0x3ca>
                            irmp_pause_time >= 2 * irmp_param.pause_1_len_max && irmp_bit >= irmp_param.complete_len - 2 && !irmp_param.stop_bit)
                        {                                                       // special manchester decoder
                            got_light = TRUE;                                   // this is a lie, but generates a stop bit ;-)
                            irmp_param.stop_bit = TRUE;                         // set flag
 850:	81 e0       	ldi	r24, 0x01	; 1
 852:	80 93 80 00 	sts	0x0080, r24
 856:	1a c0       	rjmp	.+52     	; 0x88c <__stack+0x2d>
                        }
                        else
#endif // IRMP_SUPPORT_MANCHESTER == 1
                        if (irmp_pause_time > IRMP_TIMEOUT_LEN)                 // timeout?
 858:	59 3f       	cpi	r21, 0xF9	; 249
 85a:	08 f4       	brcc	.+2      	; 0x85e <irmp_ISR+0x3d0>
 85c:	d2 c0       	rjmp	.+420    	; 0xa02 <__stack+0x1a3>
                        {                                                       // yes...
                            if (irmp_bit == irmp_param.complete_len - 1 && irmp_param.stop_bit == 0)
 85e:	24 2f       	mov	r18, r20
 860:	30 e0       	ldi	r19, 0x00	; 0
 862:	86 2f       	mov	r24, r22
 864:	90 e0       	ldi	r25, 0x00	; 0
 866:	01 97       	sbiw	r24, 0x01	; 1
 868:	28 17       	cp	r18, r24
 86a:	39 07       	cpc	r19, r25
 86c:	41 f4       	brne	.+16     	; 0x87e <__stack+0x1f>
 86e:	80 91 80 00 	lds	r24, 0x0080
 872:	88 23       	and	r24, r24
 874:	21 f4       	brne	.+8      	; 0x87e <__stack+0x1f>
                            {
                                irmp_bit++;
 876:	4f 5f       	subi	r20, 0xFF	; 255
 878:	40 93 71 00 	sts	0x0071, r20
 87c:	c2 c0       	rjmp	.+388    	; 0xa02 <__stack+0x1a3>
                            {
                                ANALYZE_PRINTF ("error 2: pause %d after data bit %d too long\n", irmp_pause_time, irmp_bit);
                                ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');

//                              irmp_busy_flag = FALSE;
                                irmp_start_bit_detected = 0;                    // wait for another start bit...
 87e:	10 92 70 00 	sts	0x0070, r1
                                irmp_pulse_time         = 0;
 882:	10 92 6d 00 	sts	0x006D, r1
                                irmp_pause_time         = 0;
 886:	10 92 6c 00 	sts	0x006C, r1
 88a:	bb c0       	rjmp	.+374    	; 0xa02 <__stack+0x1a3>
                if (got_light)
                {
                    ANALYZE_PRINTF ("%8d [bit %2d: pulse = %3d, pause = %3d] ", time_counter, irmp_bit, irmp_pulse_time, irmp_pause_time);

#if IRMP_SUPPORT_MANCHESTER == 1
                    if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER))                                     // Manchester
 88c:	80 91 82 00 	lds	r24, 0x0082
 890:	28 2f       	mov	r18, r24
 892:	30 e0       	ldi	r19, 0x00	; 0
 894:	80 ff       	sbrs	r24, 0
 896:	47 c0       	rjmp	.+142    	; 0x926 <__stack+0xc7>
                    {
#if 1
                        if (irmp_pulse_time > irmp_param.pulse_1_len_max /* && irmp_pulse_time <= 2 * irmp_param.pulse_1_len_max */)
 898:	90 91 6d 00 	lds	r25, 0x006D
 89c:	80 91 74 00 	lds	r24, 0x0074
 8a0:	89 17       	cp	r24, r25
 8a2:	c0 f4       	brcc	.+48     	; 0x8d4 <__stack+0x75>
                            }
                            else
#endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
                            {
                                ANALYZE_PUTCHAR ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? '0' : '1');
                                irmp_store_bit ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 0  :  1 );
 8a4:	36 95       	lsr	r19
 8a6:	27 95       	ror	r18
 8a8:	82 2f       	mov	r24, r18
 8aa:	80 95       	com	r24
 8ac:	81 70       	andi	r24, 0x01	; 1
 8ae:	0e 94 48 01 	call	0x290	; 0x290 <irmp_store_bit>
                                }
                                else
#endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
                                {
                                    ANALYZE_PUTCHAR ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? '1' : '0');
                                    irmp_store_bit ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 1 :   0 );
 8b2:	80 91 82 00 	lds	r24, 0x0082
 8b6:	90 e0       	ldi	r25, 0x00	; 0
 8b8:	96 95       	lsr	r25
 8ba:	87 95       	ror	r24
 8bc:	81 70       	andi	r24, 0x01	; 1
 8be:	0e 94 48 01 	call	0x290	; 0x290 <irmp_store_bit>
                                    if (! irmp_param2.protocol)
#endif
                                    {
                                        ANALYZE_NEWLINE ();
                                    }
                                    last_value = (irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 1 : 0;
 8c2:	80 91 82 00 	lds	r24, 0x0082
 8c6:	90 e0       	ldi	r25, 0x00	; 0
 8c8:	96 95       	lsr	r25
 8ca:	87 95       	ror	r24
 8cc:	81 70       	andi	r24, 0x01	; 1
 8ce:	80 93 64 00 	sts	0x0064, r24
 8d2:	24 c0       	rjmp	.+72     	; 0x91c <__stack+0xbd>
                                }
                            }
                        }
                        else if (irmp_pulse_time >= irmp_param.pulse_1_len_min && irmp_pulse_time <= irmp_param.pulse_1_len_max
 8d4:	80 91 73 00 	lds	r24, 0x0073
 8d8:	98 17       	cp	r25, r24
 8da:	e0 f0       	brcs	.+56     	; 0x914 <__stack+0xb5>
                                 /* && irmp_pause_time <= 2 * irmp_param.pause_1_len_max */)
                        {
                            uint8_t manchester_value;

                            if (last_pause > irmp_param.pause_1_len_max && last_pause <= 2 * irmp_param.pause_1_len_max)
 8dc:	20 91 65 00 	lds	r18, 0x0065
 8e0:	80 91 76 00 	lds	r24, 0x0076
 8e4:	82 17       	cp	r24, r18
 8e6:	80 f4       	brcc	.+32     	; 0x908 <__stack+0xa9>
 8e8:	30 e0       	ldi	r19, 0x00	; 0
 8ea:	90 e0       	ldi	r25, 0x00	; 0
 8ec:	88 0f       	add	r24, r24
 8ee:	99 1f       	adc	r25, r25
 8f0:	82 17       	cp	r24, r18
 8f2:	93 07       	cpc	r25, r19
 8f4:	4c f0       	brlt	.+18     	; 0x908 <__stack+0xa9>
                            {
                                manchester_value = last_value ? 0 : 1;
 8f6:	90 e0       	ldi	r25, 0x00	; 0
 8f8:	80 91 64 00 	lds	r24, 0x0064
 8fc:	88 23       	and	r24, r24
 8fe:	09 f4       	brne	.+2      	; 0x902 <__stack+0xa3>
 900:	91 e0       	ldi	r25, 0x01	; 1
                                last_value  = manchester_value;
 902:	90 93 64 00 	sts	0x0064, r25
 906:	02 c0       	rjmp	.+4      	; 0x90c <__stack+0xad>
                            }
                            else
                            {
                                manchester_value = last_value;
 908:	90 91 64 00 	lds	r25, 0x0064
                                irmp_param.command_end = irmp_param.command_offset + 16 - 1;
                                irmp_tmp_address = 0;
                            }
#endif // IRMP_SUPPORT_RC6_PROTOCOL == 1

                            irmp_store_bit (manchester_value);
 90c:	89 2f       	mov	r24, r25
 90e:	0e 94 48 01 	call	0x290	; 0x290 <irmp_store_bit>
 912:	04 c0       	rjmp	.+8      	; 0x91c <__stack+0xbd>
                                ANALYZE_PUTCHAR ('?');
                                ANALYZE_NEWLINE ();
                                ANALYZE_PRINTF ("error 3 manchester: timing not correct: data bit %d,  pulse: %d, pause: %d\n", irmp_bit, irmp_pulse_time, irmp_pause_time);
                                ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
//                              irmp_busy_flag = FALSE;
                                irmp_start_bit_detected = 0;                            // reset flags and wait for next start bit
 914:	10 92 70 00 	sts	0x0070, r1
                                irmp_pause_time         = 0;
 918:	10 92 6c 00 	sts	0x006C, r1
                                irmp_tmp_command = irmp_tmp_command2;
                            }
                        }
#endif // IRMP_SUPPORT_RCCAR_PROTOCOL == 1

                        last_pause      = irmp_pause_time;
 91c:	80 91 6c 00 	lds	r24, 0x006C
 920:	80 93 65 00 	sts	0x0065, r24
 924:	44 c0       	rjmp	.+136    	; 0x9ae <__stack+0x14f>
                    }
                    else
#endif // IRMP_SUPPORT_SERIAL == 1

#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
                    if (irmp_param.protocol == IRMP_SAMSUNG_PROTOCOL && irmp_bit == 16)       // Samsung: 16th bit
 926:	80 91 72 00 	lds	r24, 0x0072
 92a:	83 30       	cpi	r24, 0x03	; 3
 92c:	49 f5       	brne	.+82     	; 0x980 <__stack+0x121>
 92e:	80 91 71 00 	lds	r24, 0x0071
 932:	80 31       	cpi	r24, 0x10	; 16
 934:	29 f5       	brne	.+74     	; 0x980 <__stack+0x121>
                    {
                        if (irmp_pulse_time >= SAMSUNG_PULSE_LEN_MIN && irmp_pulse_time <= SAMSUNG_PULSE_LEN_MAX &&
 936:	80 91 6d 00 	lds	r24, 0x006D
 93a:	85 50       	subi	r24, 0x05	; 5
 93c:	88 30       	cpi	r24, 0x08	; 8
 93e:	08 f0       	brcs	.+2      	; 0x942 <__stack+0xe3>
 940:	4d c0       	rjmp	.+154    	; 0x9dc <__stack+0x17d>
 942:	90 91 6c 00 	lds	r25, 0x006C
 946:	9c 33       	cpi	r25, 0x3C	; 60
 948:	60 f0       	brcs	.+24     	; 0x962 <__stack+0x103>
 94a:	9c 34       	cpi	r25, 0x4C	; 76
 94c:	50 f4       	brcc	.+20     	; 0x962 <__stack+0x103>
                            irmp_pause_time >= SAMSUNG_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= SAMSUNG_START_BIT_PAUSE_LEN_MAX)
                        {
                            ANALYZE_PRINTF ("SYNC\n");
                            wait_for_space = 0;
 94e:	10 92 6f 00 	sts	0x006F, r1
                            irmp_tmp_id = 0;
 952:	10 92 91 00 	sts	0x0091, r1
 956:	10 92 90 00 	sts	0x0090, r1
                            irmp_bit++;
 95a:	81 e1       	ldi	r24, 0x11	; 17
 95c:	80 93 71 00 	sts	0x0071, r24
 960:	41 c0       	rjmp	.+130    	; 0x9e4 <__stack+0x185>
                        }
                        else  if (irmp_pulse_time >= SAMSUNG_PULSE_LEN_MIN && irmp_pulse_time <= SAMSUNG_PULSE_LEN_MAX)
                        {
                            irmp_param.protocol         = IRMP_SAMSUNG32_PROTOCOL;
 962:	8a e0       	ldi	r24, 0x0A	; 10
 964:	80 93 72 00 	sts	0x0072, r24
                            irmp_param.command_offset   = SAMSUNG32_COMMAND_OFFSET;
 968:	80 e1       	ldi	r24, 0x10	; 16
 96a:	80 93 7d 00 	sts	0x007D, r24
                            irmp_param.command_end      = SAMSUNG32_COMMAND_OFFSET + SAMSUNG32_COMMAND_LEN;
 96e:	80 e2       	ldi	r24, 0x20	; 32
 970:	80 93 7e 00 	sts	0x007E, r24
                            irmp_param.complete_len     = SAMSUNG32_COMPLETE_DATA_LEN;
 974:	80 93 7f 00 	sts	0x007F, r24

                            if (irmp_pause_time >= SAMSUNG_1_PAUSE_LEN_MIN && irmp_pause_time <= SAMSUNG_1_PAUSE_LEN_MAX)
 978:	9e 50       	subi	r25, 0x0E	; 14
 97a:	90 31       	cpi	r25, 0x10	; 16
 97c:	68 f5       	brcc	.+90     	; 0x9d8 <__stack+0x179>
 97e:	14 c0       	rjmp	.+40     	; 0x9a8 <__stack+0x149>
                        }
                    }
                    else
#endif // IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL

                    if (irmp_pulse_time >= irmp_param.pulse_1_len_min && irmp_pulse_time <= irmp_param.pulse_1_len_max &&
 980:	90 91 6d 00 	lds	r25, 0x006D
 984:	80 91 73 00 	lds	r24, 0x0073
 988:	98 17       	cp	r25, r24
 98a:	a0 f0       	brcs	.+40     	; 0x9b4 <__stack+0x155>
 98c:	80 91 74 00 	lds	r24, 0x0074
 990:	89 17       	cp	r24, r25
 992:	80 f0       	brcs	.+32     	; 0x9b4 <__stack+0x155>
 994:	20 91 6c 00 	lds	r18, 0x006C
 998:	80 91 75 00 	lds	r24, 0x0075
 99c:	28 17       	cp	r18, r24
 99e:	50 f0       	brcs	.+20     	; 0x9b4 <__stack+0x155>
 9a0:	80 91 76 00 	lds	r24, 0x0076
 9a4:	82 17       	cp	r24, r18
 9a6:	30 f0       	brcs	.+12     	; 0x9b4 <__stack+0x155>
                        irmp_pause_time >= irmp_param.pause_1_len_min && irmp_pause_time <= irmp_param.pause_1_len_max)
                    {                                                               // pulse & pause timings correct for "1"?
                        ANALYZE_PUTCHAR ('1');
                        ANALYZE_NEWLINE ();
                        irmp_store_bit (1);
 9a8:	81 e0       	ldi	r24, 0x01	; 1
 9aa:	0e 94 48 01 	call	0x290	; 0x290 <irmp_store_bit>
                        wait_for_space = 0;
 9ae:	10 92 6f 00 	sts	0x006F, r1
 9b2:	18 c0       	rjmp	.+48     	; 0x9e4 <__stack+0x185>
                    }
                    else if (irmp_pulse_time >= irmp_param.pulse_0_len_min && irmp_pulse_time <= irmp_param.pulse_0_len_max &&
 9b4:	80 91 77 00 	lds	r24, 0x0077
 9b8:	98 17       	cp	r25, r24
 9ba:	80 f0       	brcs	.+32     	; 0x9dc <__stack+0x17d>
 9bc:	80 91 78 00 	lds	r24, 0x0078
 9c0:	89 17       	cp	r24, r25
 9c2:	60 f0       	brcs	.+24     	; 0x9dc <__stack+0x17d>
 9c4:	90 91 6c 00 	lds	r25, 0x006C
 9c8:	80 91 79 00 	lds	r24, 0x0079
 9cc:	98 17       	cp	r25, r24
 9ce:	30 f0       	brcs	.+12     	; 0x9dc <__stack+0x17d>
 9d0:	80 91 7a 00 	lds	r24, 0x007A
 9d4:	89 17       	cp	r24, r25
 9d6:	10 f0       	brcs	.+4      	; 0x9dc <__stack+0x17d>
                             irmp_pause_time >= irmp_param.pause_0_len_min && irmp_pause_time <= irmp_param.pause_0_len_max)
                    {                                                               // pulse & pause timings correct for "0"?
                        ANALYZE_PUTCHAR ('0');
                        ANALYZE_NEWLINE ();
                        irmp_store_bit (0);
 9d8:	80 e0       	ldi	r24, 0x00	; 0
 9da:	e7 cf       	rjmp	.-50     	; 0x9aa <__stack+0x14b>
#endif // IRMP_SUPPORT_KATHREIN_PROTOCOL
                    {                                                               // timing incorrect!
                        ANALYZE_PRINTF ("error 3: timing not correct: data bit %d,  pulse: %d, pause: %d\n", irmp_bit, irmp_pulse_time, irmp_pause_time);
                        ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
//                      irmp_busy_flag = FALSE;
                        irmp_start_bit_detected = 0;                                // reset flags and wait for next start bit
 9dc:	10 92 70 00 	sts	0x0070, r1
                        irmp_pause_time         = 0;
 9e0:	10 92 6c 00 	sts	0x006C, r1
                    }

                    irmp_pulse_time = 1;                                            // set counter to 1, not 0
 9e4:	81 e0       	ldi	r24, 0x01	; 1
 9e6:	05 c0       	rjmp	.+10     	; 0x9f2 <__stack+0x193>
                }
            }
            else
            {                                                                       // counting the pulse length ...
                if (! irmp_input)                                                   // still light?
 9e8:	99 23       	and	r25, r25
 9ea:	31 f4       	brne	.+12     	; 0x9f8 <__stack+0x199>
                {                                                                   // yes...
                    irmp_pulse_time++;                                              // increment counter
 9ec:	80 91 6d 00 	lds	r24, 0x006D
 9f0:	8f 5f       	subi	r24, 0xFF	; 255
 9f2:	80 93 6d 00 	sts	0x006D, r24
 9f6:	05 c0       	rjmp	.+10     	; 0xa02 <__stack+0x1a3>
                }
                else
                {                                                                   // now it's dark!
                    wait_for_space  = 1;                                            // let's count the time (see above)
 9f8:	81 e0       	ldi	r24, 0x01	; 1
 9fa:	80 93 6f 00 	sts	0x006F, r24
                    irmp_pause_time = 1;                                            // set pause counter to 1, not 0
 9fe:	80 93 6c 00 	sts	0x006C, r24
                }
            }

            if (irmp_start_bit_detected && irmp_bit == irmp_param.complete_len && irmp_param.stop_bit == 0)    // enough bits received?
 a02:	80 91 70 00 	lds	r24, 0x0070
 a06:	88 23       	and	r24, r24
 a08:	09 f4       	brne	.+2      	; 0xa0c <__stack+0x1ad>
 a0a:	2c c1       	rjmp	.+600    	; 0xc64 <__stack+0x405>
 a0c:	20 91 71 00 	lds	r18, 0x0071
 a10:	80 91 7f 00 	lds	r24, 0x007F
 a14:	28 17       	cp	r18, r24
 a16:	09 f0       	breq	.+2      	; 0xa1a <__stack+0x1bb>
 a18:	25 c1       	rjmp	.+586    	; 0xc64 <__stack+0x405>
 a1a:	80 91 80 00 	lds	r24, 0x0080
 a1e:	88 23       	and	r24, r24
 a20:	09 f0       	breq	.+2      	; 0xa24 <__stack+0x1c5>
 a22:	20 c1       	rjmp	.+576    	; 0xc64 <__stack+0x405>
            {
                if (last_irmp_command == irmp_tmp_command && repetition_len < AUTO_FRAME_REPETITION_LEN)
 a24:	60 91 8e 00 	lds	r22, 0x008E
 a28:	70 91 8f 00 	lds	r23, 0x008F
 a2c:	80 91 60 00 	lds	r24, 0x0060
 a30:	90 91 61 00 	lds	r25, 0x0061
 a34:	86 17       	cp	r24, r22
 a36:	97 07       	cpc	r25, r23
 a38:	69 f4       	brne	.+26     	; 0xa54 <__stack+0x1f5>
 a3a:	80 91 6a 00 	lds	r24, 0x006A
 a3e:	90 91 6b 00 	lds	r25, 0x006B
 a42:	80 5b       	subi	r24, 0xB0	; 176
 a44:	94 40       	sbci	r25, 0x04	; 4
 a46:	30 f4       	brcc	.+12     	; 0xa54 <__stack+0x1f5>
                {
                    repetition_frame_number++;
 a48:	80 91 69 00 	lds	r24, 0x0069
 a4c:	8f 5f       	subi	r24, 0xFF	; 255
 a4e:	80 93 69 00 	sts	0x0069, r24
 a52:	02 c0       	rjmp	.+4      	; 0xa58 <__stack+0x1f9>
                }
                else
                {
                    repetition_frame_number = 0;
 a54:	10 92 69 00 	sts	0x0069, r1
                }

#if IRMP_SUPPORT_SIRCS_PROTOCOL == 1
                // if SIRCS protocol and the code will be repeated within 50 ms, we will ignore 2nd and 3rd repetition frame
                if (irmp_param.protocol == IRMP_SIRCS_PROTOCOL && (repetition_frame_number == 1 || repetition_frame_number == 2))
 a58:	50 91 72 00 	lds	r21, 0x0072
 a5c:	51 30       	cpi	r21, 0x01	; 1
 a5e:	31 f4       	brne	.+12     	; 0xa6c <__stack+0x20d>
 a60:	80 91 69 00 	lds	r24, 0x0069
 a64:	81 50       	subi	r24, 0x01	; 1
 a66:	82 30       	cpi	r24, 0x02	; 2
 a68:	98 f4       	brcc	.+38     	; 0xa90 <__stack+0x231>
 a6a:	0d c0       	rjmp	.+26     	; 0xa86 <__stack+0x227>
                else
#endif

#if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
                // if KASEIKYO protocol and the code will be repeated within 50 ms, we will ignore 2nd repetition frame
                if (irmp_param.protocol == IRMP_KASEIKYO_PROTOCOL && repetition_frame_number == 1)
 a6c:	55 30       	cpi	r21, 0x05	; 5
 a6e:	29 f4       	brne	.+10     	; 0xa7a <__stack+0x21b>
 a70:	80 91 69 00 	lds	r24, 0x0069
 a74:	81 30       	cpi	r24, 0x01	; 1
 a76:	61 f4       	brne	.+24     	; 0xa90 <__stack+0x231>
 a78:	06 c0       	rjmp	.+12     	; 0xa86 <__stack+0x227>
                else
#endif

#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
                // if SAMSUNG32 protocol and the code will be repeated within 50 ms, we will ignore every 2nd frame
                if (irmp_param.protocol == IRMP_SAMSUNG32_PROTOCOL && (repetition_frame_number & 0x01))
 a7a:	5a 30       	cpi	r21, 0x0A	; 10
 a7c:	49 f4       	brne	.+18     	; 0xa90 <__stack+0x231>
 a7e:	80 91 69 00 	lds	r24, 0x0069
 a82:	80 ff       	sbrs	r24, 0
 a84:	05 c0       	rjmp	.+10     	; 0xa90 <__stack+0x231>
                {
                    ANALYZE_PRINTF ("code skipped: SAMSUNG32 auto repetition frame #%d, counter = %d, auto repetition len = %d\n",
                                    repetition_frame_number + 1, repetition_len, AUTO_FRAME_REPETITION_LEN);
                    repetition_len = 0;
 a86:	10 92 6b 00 	sts	0x006B, r1
 a8a:	10 92 6a 00 	sts	0x006A, r1
 a8e:	aa c0       	rjmp	.+340    	; 0xbe4 <__stack+0x385>
                else
#endif

                {
                    ANALYZE_PRINTF ("%8d code detected, length = %d\n", time_counter, irmp_bit);
                    irmp_ir_detected = TRUE;
 a90:	81 e0       	ldi	r24, 0x01	; 1
 a92:	80 93 83 00 	sts	0x0083, r24

#if IRMP_SUPPORT_DENON_PROTOCOL == 1
                    if (irmp_param.protocol == IRMP_DENON_PROTOCOL)
 a96:	58 30       	cpi	r21, 0x08	; 8
 a98:	29 f5       	brne	.+74     	; 0xae4 <__stack+0x285>
                    {                                                               // check for repetition frame
                        if ((~irmp_tmp_command & 0x3FF) == last_irmp_denon_command) // command bits must be inverted
 a9a:	9b 01       	movw	r18, r22
 a9c:	20 95       	com	r18
 a9e:	30 95       	com	r19
 aa0:	33 70       	andi	r19, 0x03	; 3
 aa2:	80 91 67 00 	lds	r24, 0x0067
 aa6:	90 91 68 00 	lds	r25, 0x0068
 aaa:	28 17       	cp	r18, r24
 aac:	39 07       	cpc	r19, r25
 aae:	99 f4       	brne	.+38     	; 0xad6 <__stack+0x277>
                        {
                            irmp_tmp_command = last_irmp_denon_command;             // use command received before!
 ab0:	30 93 8f 00 	sts	0x008F, r19
 ab4:	20 93 8e 00 	sts	0x008E, r18

                            irmp_protocol = irmp_param.protocol;                    // store protocol
 ab8:	50 93 84 00 	sts	0x0084, r21
                            irmp_address = irmp_tmp_address;                        // store address
 abc:	80 91 8c 00 	lds	r24, 0x008C
 ac0:	90 91 8d 00 	lds	r25, 0x008D
 ac4:	90 93 86 00 	sts	0x0086, r25
 ac8:	80 93 85 00 	sts	0x0085, r24
                            irmp_command = irmp_tmp_command ;                       // store command
 acc:	30 93 88 00 	sts	0x0088, r19
 ad0:	20 93 87 00 	sts	0x0087, r18
 ad4:	87 c0       	rjmp	.+270    	; 0xbe4 <__stack+0x385>
                        }
                        else
                        {
                            ANALYZE_PRINTF ("waiting for inverted command repetition\n");
                            irmp_ir_detected = FALSE;
 ad6:	10 92 83 00 	sts	0x0083, r1
                            last_irmp_denon_command = irmp_tmp_command;
 ada:	70 93 68 00 	sts	0x0068, r23
 ade:	60 93 67 00 	sts	0x0067, r22
 ae2:	80 c0       	rjmp	.+256    	; 0xbe4 <__stack+0x385>
                    }
                    else
#endif // IRMP_SUPPORT_NOKIA_PROTOCOL
                    {
#if IRMP_SUPPORT_NEC_PROTOCOL == 1
                        if (irmp_param.protocol == IRMP_NEC_PROTOCOL && irmp_bit == 0)  // repetition frame
 ae4:	52 30       	cpi	r21, 0x02	; 2
 ae6:	29 f5       	brne	.+74     	; 0xb32 <__stack+0x2d3>
 ae8:	22 23       	and	r18, r18
 aea:	09 f0       	breq	.+2      	; 0xaee <__stack+0x28f>
 aec:	4b c0       	rjmp	.+150    	; 0xb84 <__stack+0x325>
                        {
                            if (repetition_len < NEC_FRAME_REPEAT_PAUSE_LEN_MAX)
 aee:	80 91 6a 00 	lds	r24, 0x006A
 af2:	90 91 6b 00 	lds	r25, 0x006B
 af6:	88 50       	subi	r24, 0x08	; 8
 af8:	97 40       	sbci	r25, 0x07	; 7
 afa:	08 f0       	brcs	.+2      	; 0xafe <__stack+0x29f>
 afc:	41 c0       	rjmp	.+130    	; 0xb80 <__stack+0x321>
                            {
                                ANALYZE_PRINTF ("Detected NEC repetition frame, repetition_len = %d\n", repetition_len);
                                irmp_tmp_address = last_irmp_address;                   // address is last address
 afe:	80 91 62 00 	lds	r24, 0x0062
 b02:	90 91 63 00 	lds	r25, 0x0063
 b06:	90 93 8d 00 	sts	0x008D, r25
 b0a:	80 93 8c 00 	sts	0x008C, r24
                                irmp_tmp_command = last_irmp_command;                   // command is last command
 b0e:	80 91 60 00 	lds	r24, 0x0060
 b12:	90 91 61 00 	lds	r25, 0x0061
 b16:	90 93 8f 00 	sts	0x008F, r25
 b1a:	80 93 8e 00 	sts	0x008E, r24
                                irmp_flags |= IRMP_FLAG_REPETITION;
 b1e:	80 91 8b 00 	lds	r24, 0x008B
 b22:	81 60       	ori	r24, 0x01	; 1
 b24:	80 93 8b 00 	sts	0x008B, r24
                                repetition_len = 0;
 b28:	10 92 6b 00 	sts	0x006B, r1
 b2c:	10 92 6a 00 	sts	0x006A, r1
 b30:	29 c0       	rjmp	.+82     	; 0xb84 <__stack+0x325>
                            }
                        }
#endif // IRMP_SUPPORT_NEC_PROTOCOL

#if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
                        if (irmp_param.protocol == IRMP_KASEIKYO_PROTOCOL)
 b32:	55 30       	cpi	r21, 0x05	; 5
 b34:	39 f5       	brne	.+78     	; 0xb84 <__stack+0x325>
                        {
                            uint8_t xor;
                            // ANALYZE_PRINTF ("0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n",
                            //                 xor_check[0], xor_check[1], xor_check[2], xor_check[3], xor_check[4], xor_check[5]);

                            xor = (xor_check[0] & 0x0F) ^ ((xor_check[0] & 0xF0) >> 4) ^ (xor_check[1] & 0x0F) ^ ((xor_check[1] & 0xF0) >> 4);
 b36:	80 91 92 00 	lds	r24, 0x0092
 b3a:	90 91 93 00 	lds	r25, 0x0093

                            if (xor != (xor_check[2] & 0x0F))
 b3e:	40 91 94 00 	lds	r20, 0x0094
 b42:	28 2f       	mov	r18, r24
 b44:	2f 70       	andi	r18, 0x0F	; 15
 b46:	82 95       	swap	r24
 b48:	8f 70       	andi	r24, 0x0F	; 15
 b4a:	28 27       	eor	r18, r24
 b4c:	89 2f       	mov	r24, r25
 b4e:	8f 70       	andi	r24, 0x0F	; 15
 b50:	28 27       	eor	r18, r24
 b52:	92 95       	swap	r25
 b54:	9f 70       	andi	r25, 0x0F	; 15
 b56:	29 27       	eor	r18, r25
 b58:	30 e0       	ldi	r19, 0x00	; 0
 b5a:	84 2f       	mov	r24, r20
 b5c:	90 e0       	ldi	r25, 0x00	; 0
 b5e:	8f 70       	andi	r24, 0x0F	; 15
 b60:	90 70       	andi	r25, 0x00	; 0
 b62:	28 17       	cp	r18, r24
 b64:	39 07       	cpc	r19, r25
 b66:	11 f0       	breq	.+4      	; 0xb6c <__stack+0x30d>
                            {
                                ANALYZE_PRINTF ("error 4: wrong XOR check for customer id: 0x%1x 0x%1x\n", xor, xor_check[2] & 0x0F);
                                irmp_ir_detected = FALSE;
 b68:	10 92 83 00 	sts	0x0083, r1
                            }

                            xor = xor_check[2] ^ xor_check[3] ^ xor_check[4];

                            if (xor != xor_check[5])
 b6c:	80 91 95 00 	lds	r24, 0x0095
 b70:	48 27       	eor	r20, r24
 b72:	80 91 96 00 	lds	r24, 0x0096
 b76:	48 27       	eor	r20, r24
 b78:	80 91 97 00 	lds	r24, 0x0097
 b7c:	48 17       	cp	r20, r24
 b7e:	11 f0       	breq	.+4      	; 0xb84 <__stack+0x325>
                            {
                                ANALYZE_PRINTF ("error 4: wrong XOR check for data bits: 0x%02x 0x%02x\n", xor, xor_check[5]);
                                irmp_ir_detected = FALSE;
 b80:	10 92 83 00 	sts	0x0083, r1
                            irmp_protocol = IRMP_RC6A_PROTOCOL;
                        }
                        else
#endif // IRMP_SUPPORT_RC6_PROTOCOL == 1

                        irmp_protocol = irmp_param.protocol;
 b84:	50 93 84 00 	sts	0x0084, r21
                            irmp_tmp_command |= (irmp_tmp_address << 2) & 0x0F00;   // 000000CCCCAAAAAA -> 0000CCCC00000000
                            irmp_tmp_address &= 0x003F;
                        }
#endif

                        irmp_address = irmp_tmp_address;                            // store address
 b88:	80 91 8c 00 	lds	r24, 0x008C
 b8c:	90 91 8d 00 	lds	r25, 0x008D
 b90:	90 93 86 00 	sts	0x0086, r25
 b94:	80 93 85 00 	sts	0x0085, r24
#if IRMP_SUPPORT_NEC_PROTOCOL == 1
                        if (irmp_param.protocol == IRMP_NEC_PROTOCOL)
 b98:	52 30       	cpi	r21, 0x02	; 2
 b9a:	29 f4       	brne	.+10     	; 0xba6 <__stack+0x347>
                        {
                            last_irmp_address = irmp_tmp_address;                   // store as last address, too
 b9c:	90 93 63 00 	sts	0x0063, r25
 ba0:	80 93 62 00 	sts	0x0062, r24
 ba4:	0f c0       	rjmp	.+30     	; 0xbc4 <__stack+0x365>
                        }
#endif

#if IRMP_SUPPORT_RC5_PROTOCOL == 1
                        if (irmp_param.protocol == IRMP_RC5_PROTOCOL)
 ba6:	57 30       	cpi	r21, 0x07	; 7
 ba8:	69 f4       	brne	.+26     	; 0xbc4 <__stack+0x365>
                        {
                            irmp_tmp_command |= rc5_cmd_bit6;                       // store bit 6
 baa:	20 91 66 00 	lds	r18, 0x0066
 bae:	30 e0       	ldi	r19, 0x00	; 0
 bb0:	80 91 8e 00 	lds	r24, 0x008E
 bb4:	90 91 8f 00 	lds	r25, 0x008F
 bb8:	82 2b       	or	r24, r18
 bba:	93 2b       	or	r25, r19
 bbc:	90 93 8f 00 	sts	0x008F, r25
 bc0:	80 93 8e 00 	sts	0x008E, r24
                        }
#endif
                        irmp_command = irmp_tmp_command;                            // store command
 bc4:	80 91 8e 00 	lds	r24, 0x008E
 bc8:	90 91 8f 00 	lds	r25, 0x008F
 bcc:	90 93 88 00 	sts	0x0088, r25
 bd0:	80 93 87 00 	sts	0x0087, r24

#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
                        irmp_id = irmp_tmp_id;
 bd4:	80 91 90 00 	lds	r24, 0x0090
 bd8:	90 91 91 00 	lds	r25, 0x0091
 bdc:	90 93 8a 00 	sts	0x008A, r25
 be0:	80 93 89 00 	sts	0x0089, r24
#endif
                    }
                }

                if (irmp_ir_detected)
 be4:	80 91 83 00 	lds	r24, 0x0083
 be8:	88 23       	and	r24, r24
 bea:	91 f1       	breq	.+100    	; 0xc50 <__stack+0x3f1>
                {
                    if (last_irmp_command == irmp_tmp_command &&
 bec:	40 91 8e 00 	lds	r20, 0x008E
 bf0:	50 91 8f 00 	lds	r21, 0x008F
 bf4:	80 91 60 00 	lds	r24, 0x0060
 bf8:	90 91 61 00 	lds	r25, 0x0061
 bfc:	84 17       	cp	r24, r20
 bfe:	95 07       	cpc	r25, r21
 c00:	b9 f4       	brne	.+46     	; 0xc30 <__stack+0x3d1>
 c02:	20 91 62 00 	lds	r18, 0x0062
 c06:	30 91 63 00 	lds	r19, 0x0063
 c0a:	80 91 8c 00 	lds	r24, 0x008C
 c0e:	90 91 8d 00 	lds	r25, 0x008D
 c12:	28 17       	cp	r18, r24
 c14:	39 07       	cpc	r19, r25
 c16:	61 f4       	brne	.+24     	; 0xc30 <__stack+0x3d1>
 c18:	80 91 6a 00 	lds	r24, 0x006A
 c1c:	90 91 6b 00 	lds	r25, 0x006B
 c20:	8a 5c       	subi	r24, 0xCA	; 202
 c22:	98 40       	sbci	r25, 0x08	; 8
 c24:	28 f4       	brcc	.+10     	; 0xc30 <__stack+0x3d1>
                        last_irmp_address == irmp_tmp_address &&
                        repetition_len < IRMP_KEY_REPETITION_LEN)
                    {
                        irmp_flags |= IRMP_FLAG_REPETITION;
 c26:	80 91 8b 00 	lds	r24, 0x008B
 c2a:	81 60       	ori	r24, 0x01	; 1
 c2c:	80 93 8b 00 	sts	0x008B, r24
                    }

                    last_irmp_address = irmp_tmp_address;                           // store as last address, too
 c30:	80 91 8c 00 	lds	r24, 0x008C
 c34:	90 91 8d 00 	lds	r25, 0x008D
 c38:	90 93 63 00 	sts	0x0063, r25
 c3c:	80 93 62 00 	sts	0x0062, r24
                    last_irmp_command = irmp_tmp_command;                           // store as last command, too
 c40:	50 93 61 00 	sts	0x0061, r21
 c44:	40 93 60 00 	sts	0x0060, r20

                    repetition_len = 0;
 c48:	10 92 6b 00 	sts	0x006B, r1
 c4c:	10 92 6a 00 	sts	0x006A, r1
                {
                    ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
                }

//              irmp_busy_flag          = FALSE;
                irmp_start_bit_detected = 0;                                        // and wait for next start bit
 c50:	10 92 70 00 	sts	0x0070, r1
                irmp_tmp_command        = 0;
 c54:	10 92 8f 00 	sts	0x008F, r1
 c58:	10 92 8e 00 	sts	0x008E, r1
                irmp_pulse_time         = 0;
 c5c:	10 92 6d 00 	sts	0x006D, r1
                irmp_pause_time         = 0;
 c60:	10 92 6c 00 	sts	0x006C, r1
                }
#endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
            }
        }
    }
    return (irmp_ir_detected);
 c64:	80 91 83 00 	lds	r24, 0x0083
}
 c68:	08 95       	ret

00000c6a <__vector_7>:
#ifdef TIM1_COMPA_vect                                                      // ATtiny84
ISR(TIM1_COMPA_vect)
#else
ISR(TIMER1_COMPA_vect)
#endif
{
 c6a:	1f 92       	push	r1
 c6c:	0f 92       	push	r0
 c6e:	0f b6       	in	r0, 0x3f	; 63
 c70:	0f 92       	push	r0
 c72:	11 24       	eor	r1, r1
 c74:	2f 93       	push	r18
 c76:	3f 93       	push	r19
 c78:	4f 93       	push	r20
 c7a:	5f 93       	push	r21
 c7c:	6f 93       	push	r22
 c7e:	7f 93       	push	r23
 c80:	8f 93       	push	r24
 c82:	9f 93       	push	r25
 c84:	af 93       	push	r26
 c86:	bf 93       	push	r27
 c88:	ef 93       	push	r30
 c8a:	ff 93       	push	r31
  (void) irmp_ISR();                                                        // call irmp ISR
 c8c:	0e 94 47 02 	call	0x48e	; 0x48e <irmp_ISR>
  // call other timer interrupt routines...
}
 c90:	ff 91       	pop	r31
 c92:	ef 91       	pop	r30
 c94:	bf 91       	pop	r27
 c96:	af 91       	pop	r26
 c98:	9f 91       	pop	r25
 c9a:	8f 91       	pop	r24
 c9c:	7f 91       	pop	r23
 c9e:	6f 91       	pop	r22
 ca0:	5f 91       	pop	r21
 ca2:	4f 91       	pop	r20
 ca4:	3f 91       	pop	r19
 ca6:	2f 91       	pop	r18
 ca8:	0f 90       	pop	r0
 caa:	0f be       	out	0x3f, r0	; 63
 cac:	0f 90       	pop	r0
 cae:	1f 90       	pop	r1
 cb0:	18 95       	reti

00000cb2 <memcpy_P>:
 cb2:	fb 01       	movw	r30, r22
 cb4:	dc 01       	movw	r26, r24
 cb6:	02 c0       	rjmp	.+4      	; 0xcbc <memcpy_P+0xa>
 cb8:	05 90       	lpm	r0, Z+
 cba:	0d 92       	st	X+, r0
 cbc:	41 50       	subi	r20, 0x01	; 1
 cbe:	50 40       	sbci	r21, 0x00	; 0
 cc0:	d8 f7       	brcc	.-10     	; 0xcb8 <memcpy_P+0x6>
 cc2:	08 95       	ret

00000cc4 <_exit>:
 cc4:	f8 94       	cli

00000cc6 <__stop_program>:
 cc6:	ff cf       	rjmp	.-2      	; 0xcc6 <__stop_program>
